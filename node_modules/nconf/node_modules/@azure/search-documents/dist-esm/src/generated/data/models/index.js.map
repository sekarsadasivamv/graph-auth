{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../src/generated/data/models/index.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG","sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\n\nimport * as coreHttp from \"@azure/core-http\";\n\n/**\n * A result containing a document found by a suggestion query, plus associated metadata.\n */\nexport interface SuggestResult {\n  /**\n   * The text of the suggestion result.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly _text: string;\n  /**\n   * Describes unknown properties. The value of an unknown property can be of \"any\" type.\n   */\n  [property: string]: any;\n}\n\n/**\n * Response containing suggestion query results from an index.\n */\nexport interface SuggestDocumentsResult {\n  /**\n   * The sequence of results returned by the query.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly results: SuggestResult[];\n  /**\n   * A value indicating the percentage of the index that was included in the query, or null if\n   * minimumCoverage was not set in the request.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly coverage?: number;\n}\n\n/**\n * A single bucket of a facet query result. Reports the number of documents with a field value\n * falling within a particular range or having a particular value or interval.\n */\nexport interface FacetResult {\n  /**\n   * The approximate count of documents falling within the bucket described by this facet.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly count?: number;\n  /**\n   * Describes unknown properties. The value of an unknown property can be of \"any\" type.\n   */\n  [property: string]: any;\n}\n\n/**\n * Parameters for filtering, sorting, faceting, paging, and other search query behaviors.\n */\nexport interface SearchRequest {\n  /**\n   * A value that specifies whether to fetch the total count of results. Default is false. Setting\n   * this value to true may have a performance impact. Note that the count returned is an\n   * approximation.\n   */\n  includeTotalResultCount?: boolean;\n  /**\n   * The list of facet expressions to apply to the search query. Each facet expression contains a\n   * field name, optionally followed by a comma-separated list of name:value pairs.\n   */\n  facets?: string[];\n  /**\n   * The OData $filter expression to apply to the search query.\n   */\n  filter?: string;\n  /**\n   * The comma-separated list of field names to use for hit highlights. Only searchable fields can\n   * be used for hit highlighting.\n   */\n  highlightFields?: string;\n  /**\n   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. Default is\n   * &lt;/em&gt;.\n   */\n  highlightPostTag?: string;\n  /**\n   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. Default\n   * is &lt;em&gt;.\n   */\n  highlightPreTag?: string;\n  /**\n   * A number between 0 and 100 indicating the percentage of the index that must be covered by a\n   * search query in order for the query to be reported as a success. This parameter can be useful\n   * for ensuring search availability even for services with only one replica. The default is 100.\n   */\n  minimumCoverage?: number;\n  /**\n   * The comma-separated list of OData $orderby expressions by which to sort the results. Each\n   * expression can be either a field name or a call to either the geo.distance() or the\n   * search.score() functions. Each expression can be followed by asc to indicate ascending, or\n   * desc to indicate descending. The default is ascending order. Ties will be broken by the match\n   * scores of documents. If no $orderby is specified, the default sort order is descending by\n   * document match score. There can be at most 32 $orderby clauses.\n   */\n  orderBy?: string;\n  /**\n   * A value that specifies the syntax of the search query. The default is 'simple'. Use 'full' if\n   * your query uses the Lucene query syntax. Possible values include: 'Simple', 'Full'\n   */\n  queryType?: QueryType;\n  /**\n   * The list of parameter values to be used in scoring functions (for example,\n   * referencePointParameter) using the format name-values. For example, if the scoring profile\n   * defines a function with a parameter called 'mylocation' the parameter string would be\n   * \"mylocation--122.2,44.8\" (without the quotes).\n   */\n  scoringParameters?: string[];\n  /**\n   * The name of a scoring profile to evaluate match scores for matching documents in order to sort\n   * the results.\n   */\n  scoringProfile?: string;\n  /**\n   * A full-text search query expression; Use \"*\" or omit this parameter to match all documents.\n   */\n  searchText?: string;\n  /**\n   * The comma-separated list of field names to which to scope the full-text search. When using\n   * fielded search (fieldName:searchExpression) in a full Lucene query, the field names of each\n   * fielded search expression take precedence over any field names listed in this parameter.\n   */\n  searchFields?: string;\n  /**\n   * A value that specifies whether any or all of the search terms must be matched in order to\n   * count the document as a match. Possible values include: 'Any', 'All'\n   */\n  searchMode?: SearchMode;\n  /**\n   * The comma-separated list of fields to retrieve. If unspecified, all fields marked as\n   * retrievable in the schema are included.\n   */\n  select?: string;\n  /**\n   * The number of search results to skip. This value cannot be greater than 100,000. If you need\n   * to scan documents in sequence, but cannot use skip due to this limitation, consider using\n   * orderby on a totally-ordered key and filter with a range query instead.\n   */\n  skip?: number;\n  /**\n   * The number of search results to retrieve. This can be used in conjunction with $skip to\n   * implement client-side paging of search results. If results are truncated due to server-side\n   * paging, the response will include a continuation token that can be used to issue another\n   * Search request for the next page of results.\n   */\n  top?: number;\n}\n\n/**\n * Contains a document found by a search query, plus associated metadata.\n */\nexport interface SearchResult {\n  /**\n   * The relevance score of the document compared to other documents returned by the query.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly _score: number;\n  /**\n   * Text fragments from the document that indicate the matching search terms, organized by each\n   * applicable field; null if hit highlighting was not enabled for the query.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly _highlights?: { [propertyName: string]: string[] };\n  /**\n   * Describes unknown properties. The value of an unknown property can be of \"any\" type.\n   */\n  [property: string]: any;\n}\n\n/**\n * Response containing search results from an index.\n */\nexport interface SearchDocumentsResult {\n  /**\n   * The total count of results found by the search operation, or null if the count was not\n   * requested. If present, the count may be greater than the number of results in this response.\n   * This can happen if you use the $top or $skip parameters, or if Azure Cognitive Search can't\n   * return all the requested documents in a single Search response.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly count?: number;\n  /**\n   * A value indicating the percentage of the index that was included in the query, or null if\n   * minimumCoverage was not specified in the request.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly coverage?: number;\n  /**\n   * The facet query results for the search operation, organized as a collection of buckets for\n   * each faceted field; null if the query did not include any facet expressions.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly facets?: { [propertyName: string]: FacetResult[] };\n  /**\n   * Continuation JSON payload returned when Azure Cognitive Search can't return all the requested\n   * results in a single Search response. You can use this JSON along with @odata.nextLink to\n   * formulate another POST Search request to get the next part of the search response.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly nextPageParameters?: SearchRequest;\n  /**\n   * The sequence of results returned by the query.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly results: SearchResult[];\n  /**\n   * Continuation URL returned when Azure Cognitive Search can't return all the requested results\n   * in a single Search response. You can use this URL to formulate another GET or POST Search\n   * request to get the next part of the search response. Make sure to use the same verb (GET or\n   * POST) as the request that produced this response.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly nextLink?: string;\n}\n\n/**\n * Represents an index action that operates on a document.\n */\nexport interface IndexAction {\n  /**\n   * The operation to perform on a document in an indexing batch. Possible values include:\n   * 'Upload', 'Merge', 'MergeOrUpload', 'Delete'\n   */\n  __actionType: IndexActionType;\n  /**\n   * Describes unknown properties. The value of an unknown property can be of \"any\" type.\n   */\n  [property: string]: any;\n}\n\n/**\n * Contains a batch of document write actions to send to the index.\n */\nexport interface IndexBatch {\n  /**\n   * The actions in the batch.\n   */\n  actions: IndexAction[];\n}\n\n/**\n * Status of an indexing operation for a single document.\n */\nexport interface IndexingResult {\n  /**\n   * The key of a document that was in the indexing request.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly key: string;\n  /**\n   * The error message explaining why the indexing operation failed for the document identified by\n   * the key; null if indexing succeeded.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly errorMessage?: string;\n  /**\n   * A value indicating whether the indexing operation succeeded for the document identified by the\n   * key.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly succeeded: boolean;\n  /**\n   * The status code of the indexing operation. Possible values include: 200 for a successful\n   * update or delete, 201 for successful document creation, 400 for a malformed input document,\n   * 404 for document not found, 409 for a version conflict, 422 when the index is temporarily\n   * unavailable, or 503 for when the service is too busy.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly statusCode: number;\n}\n\n/**\n * Response containing the status of operations for all documents in the indexing request.\n */\nexport interface IndexDocumentsResult {\n  /**\n   * The list of status information for each document in the indexing request.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly results: IndexingResult[];\n}\n\n/**\n * Parameters for filtering, sorting, fuzzy matching, and other suggestions query behaviors.\n */\nexport interface SuggestRequest {\n  /**\n   * An OData expression that filters the documents considered for suggestions.\n   */\n  filter?: string;\n  /**\n   * A value indicating whether to use fuzzy matching for the suggestion query. Default is false.\n   * When set to true, the query will find suggestions even if there's a substituted or missing\n   * character in the search text. While this provides a better experience in some scenarios, it\n   * comes at a performance cost as fuzzy suggestion searches are slower and consume more\n   * resources.\n   */\n  useFuzzyMatching?: boolean;\n  /**\n   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. If omitted,\n   * hit highlighting of suggestions is disabled.\n   */\n  highlightPostTag?: string;\n  /**\n   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. If\n   * omitted, hit highlighting of suggestions is disabled.\n   */\n  highlightPreTag?: string;\n  /**\n   * A number between 0 and 100 indicating the percentage of the index that must be covered by a\n   * suggestion query in order for the query to be reported as a success. This parameter can be\n   * useful for ensuring search availability even for services with only one replica. The default\n   * is 80.\n   */\n  minimumCoverage?: number;\n  /**\n   * The comma-separated list of OData $orderby expressions by which to sort the results. Each\n   * expression can be either a field name or a call to either the geo.distance() or the\n   * search.score() functions. Each expression can be followed by asc to indicate ascending, or\n   * desc to indicate descending. The default is ascending order. Ties will be broken by the match\n   * scores of documents. If no $orderby is specified, the default sort order is descending by\n   * document match score. There can be at most 32 $orderby clauses.\n   */\n  orderBy?: string;\n  /**\n   * The search text to use to suggest documents. Must be at least 1 character, and no more than\n   * 100 characters.\n   */\n  searchText: string;\n  /**\n   * The comma-separated list of field names to search for the specified search text. Target fields\n   * must be included in the specified suggester.\n   */\n  searchFields?: string;\n  /**\n   * The comma-separated list of fields to retrieve. If unspecified, only the key field will be\n   * included in the results.\n   */\n  select?: string;\n  /**\n   * The name of the suggester as specified in the suggesters collection that's part of the index\n   * definition.\n   */\n  suggesterName: string;\n  /**\n   * The number of suggestions to retrieve. This must be a value between 1 and 100. The default is\n   * 5.\n   */\n  top?: number;\n}\n\n/**\n * Parameters for fuzzy matching, and other autocomplete query behaviors.\n */\nexport interface AutocompleteRequest {\n  /**\n   * The search text on which to base autocomplete results.\n   */\n  searchText: string;\n  /**\n   * Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms' to get shingles\n   * and 'oneTermWithContext' to use the current context while producing auto-completed terms.\n   * Possible values include: 'OneTerm', 'TwoTerms', 'OneTermWithContext'\n   */\n  autocompleteMode?: AutocompleteMode;\n  /**\n   * An OData expression that filters the documents used to produce completed terms for the\n   * Autocomplete result.\n   */\n  filter?: string;\n  /**\n   * A value indicating whether to use fuzzy matching for the autocomplete query. Default is false.\n   * When set to true, the query will autocomplete terms even if there's a substituted or missing\n   * character in the search text. While this provides a better experience in some scenarios, it\n   * comes at a performance cost as fuzzy autocomplete queries are slower and consume more\n   * resources.\n   */\n  useFuzzyMatching?: boolean;\n  /**\n   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. If omitted,\n   * hit highlighting is disabled.\n   */\n  highlightPostTag?: string;\n  /**\n   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. If\n   * omitted, hit highlighting is disabled.\n   */\n  highlightPreTag?: string;\n  /**\n   * A number between 0 and 100 indicating the percentage of the index that must be covered by an\n   * autocomplete query in order for the query to be reported as a success. This parameter can be\n   * useful for ensuring search availability even for services with only one replica. The default\n   * is 80.\n   */\n  minimumCoverage?: number;\n  /**\n   * The comma-separated list of field names to consider when querying for auto-completed terms.\n   * Target fields must be included in the specified suggester.\n   */\n  searchFields?: string;\n  /**\n   * The name of the suggester as specified in the suggesters collection that's part of the index\n   * definition.\n   */\n  suggesterName: string;\n  /**\n   * The number of auto-completed terms to retrieve. This must be a value between 1 and 100. The\n   * default is 5.\n   */\n  top?: number;\n}\n\n/**\n * The result of Autocomplete requests.\n */\nexport interface AutocompleteItem {\n  /**\n   * The completed term.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly text: string;\n  /**\n   * The query along with the completed term.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly queryPlusText: string;\n}\n\n/**\n * The result of Autocomplete query.\n */\nexport interface AutocompleteResult {\n  /**\n   * A value indicating the percentage of the index that was considered by the autocomplete\n   * request, or null if minimumCoverage was not specified in the request.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly coverage?: number;\n  /**\n   * The list of returned Autocompleted items.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly results: AutocompleteItem[];\n}\n\n/**\n * Describes an error condition for the Azure Cognitive Search API.\n */\nexport interface SearchError {\n  /**\n   * One of a server-defined set of error codes.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly code?: string;\n  /**\n   * A human-readable representation of the error.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly message: string;\n  /**\n   * An array of details about specific errors that led to this reported error.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  readonly details?: SearchError[];\n}\n\n/**\n * Additional parameters for searchGet operation.\n */\nexport interface SearchOptions {\n  /**\n   * A value that specifies whether to fetch the total count of results. Default is false. Setting\n   * this value to true may have a performance impact. Note that the count returned is an\n   * approximation.\n   */\n  includeTotalResultCount?: boolean;\n  /**\n   * The list of facet expressions to apply to the search query. Each facet expression contains a\n   * field name, optionally followed by a comma-separated list of name:value pairs.\n   */\n  facets?: string[];\n  /**\n   * The OData $filter expression to apply to the search query.\n   */\n  filter?: string;\n  /**\n   * The list of field names to use for hit highlights. Only searchable fields can be used for hit\n   * highlighting.\n   */\n  highlightFields?: string[];\n  /**\n   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. Default is\n   * &lt;/em&gt;.\n   */\n  highlightPostTag?: string;\n  /**\n   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. Default\n   * is &lt;em&gt;.\n   */\n  highlightPreTag?: string;\n  /**\n   * A number between 0 and 100 indicating the percentage of the index that must be covered by a\n   * search query in order for the query to be reported as a success. This parameter can be useful\n   * for ensuring search availability even for services with only one replica. The default is 100.\n   */\n  minimumCoverage?: number;\n  /**\n   * The list of OData $orderby expressions by which to sort the results. Each expression can be\n   * either a field name or a call to either the geo.distance() or the search.score() functions.\n   * Each expression can be followed by asc to indicate ascending, and desc to indicate descending.\n   * The default is ascending order. Ties will be broken by the match scores of documents. If no\n   * OrderBy is specified, the default sort order is descending by document match score. There can\n   * be at most 32 $orderby clauses.\n   */\n  orderBy?: string[];\n  /**\n   * A value that specifies the syntax of the search query. The default is 'simple'. Use 'full' if\n   * your query uses the Lucene query syntax. Possible values include: 'Simple', 'Full'\n   */\n  queryType?: QueryType;\n  /**\n   * The list of parameter values to be used in scoring functions (for example,\n   * referencePointParameter) using the format name-values. For example, if the scoring profile\n   * defines a function with a parameter called 'mylocation' the parameter string would be\n   * \"mylocation--122.2,44.8\" (without the quotes).\n   */\n  scoringParameters?: string[];\n  /**\n   * The name of a scoring profile to evaluate match scores for matching documents in order to sort\n   * the results.\n   */\n  scoringProfile?: string;\n  /**\n   * The list of field names to which to scope the full-text search. When using fielded search\n   * (fieldName:searchExpression) in a full Lucene query, the field names of each fielded search\n   * expression take precedence over any field names listed in this parameter.\n   */\n  searchFields?: string[];\n  /**\n   * A value that specifies whether any or all of the search terms must be matched in order to\n   * count the document as a match. Possible values include: 'Any', 'All'\n   */\n  searchMode?: SearchMode;\n  /**\n   * The list of fields to retrieve. If unspecified, all fields marked as retrievable in the schema\n   * are included.\n   */\n  select?: string[];\n  /**\n   * The number of search results to skip. This value cannot be greater than 100,000. If you need\n   * to scan documents in sequence, but cannot use $skip due to this limitation, consider using\n   * $orderby on a totally-ordered key and $filter with a range query instead.\n   */\n  skip?: number;\n  /**\n   * The number of search results to retrieve. This can be used in conjunction with $skip to\n   * implement client-side paging of search results. If results are truncated due to server-side\n   * paging, the response will include a continuation token that can be used to issue another\n   * Search request for the next page of results.\n   */\n  top?: number;\n}\n\n/**\n * Additional parameters for suggestGet operation.\n */\nexport interface SuggestOptions {\n  /**\n   * An OData expression that filters the documents considered for suggestions.\n   */\n  filter?: string;\n  /**\n   * A value indicating whether to use fuzzy matching for the suggestions query. Default is false.\n   * When set to true, the query will find terms even if there's a substituted or missing character\n   * in the search text. While this provides a better experience in some scenarios, it comes at a\n   * performance cost as fuzzy suggestions queries are slower and consume more resources.\n   */\n  useFuzzyMatching?: boolean;\n  /**\n   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. If omitted,\n   * hit highlighting of suggestions is disabled.\n   */\n  highlightPostTag?: string;\n  /**\n   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. If\n   * omitted, hit highlighting of suggestions is disabled.\n   */\n  highlightPreTag?: string;\n  /**\n   * A number between 0 and 100 indicating the percentage of the index that must be covered by a\n   * suggestions query in order for the query to be reported as a success. This parameter can be\n   * useful for ensuring search availability even for services with only one replica. The default\n   * is 80.\n   */\n  minimumCoverage?: number;\n  /**\n   * The list of OData $orderby expressions by which to sort the results. Each expression can be\n   * either a field name or a call to either the geo.distance() or the search.score() functions.\n   * Each expression can be followed by asc to indicate ascending, or desc to indicate descending.\n   * The default is ascending order. Ties will be broken by the match scores of documents. If no\n   * $orderby is specified, the default sort order is descending by document match score. There can\n   * be at most 32 $orderby clauses.\n   */\n  orderBy?: string[];\n  /**\n   * The list of field names to search for the specified search text. Target fields must be\n   * included in the specified suggester.\n   */\n  searchFields?: string[];\n  /**\n   * The list of fields to retrieve. If unspecified, only the key field will be included in the\n   * results.\n   */\n  select?: string[];\n  /**\n   * The number of suggestions to retrieve. The value must be a number between 1 and 100. The\n   * default is 5.\n   */\n  top?: number;\n}\n\n/**\n * Additional parameters for autocompleteGet operation.\n */\nexport interface AutocompleteOptions {\n  /**\n   * Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms' to get shingles\n   * and 'oneTermWithContext' to use the current context while producing auto-completed terms.\n   * Possible values include: 'OneTerm', 'TwoTerms', 'OneTermWithContext'\n   */\n  autocompleteMode?: AutocompleteMode;\n  /**\n   * An OData expression that filters the documents used to produce completed terms for the\n   * Autocomplete result.\n   */\n  filter?: string;\n  /**\n   * A value indicating whether to use fuzzy matching for the autocomplete query. Default is false.\n   * When set to true, the query will find terms even if there's a substituted or missing character\n   * in the search text. While this provides a better experience in some scenarios, it comes at a\n   * performance cost as fuzzy autocomplete queries are slower and consume more resources.\n   */\n  useFuzzyMatching?: boolean;\n  /**\n   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. If omitted,\n   * hit highlighting is disabled.\n   */\n  highlightPostTag?: string;\n  /**\n   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. If\n   * omitted, hit highlighting is disabled.\n   */\n  highlightPreTag?: string;\n  /**\n   * A number between 0 and 100 indicating the percentage of the index that must be covered by an\n   * autocomplete query in order for the query to be reported as a success. This parameter can be\n   * useful for ensuring search availability even for services with only one replica. The default\n   * is 80.\n   */\n  minimumCoverage?: number;\n  /**\n   * The list of field names to consider when querying for auto-completed terms. Target fields must\n   * be included in the specified suggester.\n   */\n  searchFields?: string[];\n  /**\n   * The number of auto-completed terms to retrieve. This must be a value between 1 and 100. The\n   * default is 5.\n   */\n  top?: number;\n}\n\n/**\n * Optional Parameters.\n */\nexport interface DocumentsSearchGetOptionalParams extends coreHttp.RequestOptionsBase {\n  /**\n   * A full-text search query expression; Use \"*\" or omit this parameter to match all documents.\n   */\n  searchText?: string;\n  /**\n   * Additional parameters for the operation\n   */\n  searchOptions?: SearchOptions;\n}\n\n/**\n * Optional Parameters.\n */\nexport interface DocumentsGetOptionalParams extends coreHttp.RequestOptionsBase {\n  /**\n   * List of field names to retrieve for the document; Any field not retrieved will be missing from\n   * the returned document.\n   */\n  selectedFields?: string[];\n}\n\n/**\n * Optional Parameters.\n */\nexport interface DocumentsSuggestGetOptionalParams extends coreHttp.RequestOptionsBase {\n  /**\n   * Additional parameters for the operation\n   */\n  suggestOptions?: SuggestOptions;\n}\n\n/**\n * Optional Parameters.\n */\nexport interface DocumentsAutocompleteGetOptionalParams extends coreHttp.RequestOptionsBase {\n  /**\n   * Additional parameters for the operation\n   */\n  autocompleteOptions?: AutocompleteOptions;\n}\n\n/**\n * Defines values for QueryType.\n * Possible values include: 'Simple', 'Full'\n * @readonly\n * @enum {string}\n */\nexport type QueryType = 'simple' | 'full';\n\n/**\n * Defines values for SearchMode.\n * Possible values include: 'Any', 'All'\n * @readonly\n * @enum {string}\n */\nexport type SearchMode = 'any' | 'all';\n\n/**\n * Defines values for IndexActionType.\n * Possible values include: 'Upload', 'Merge', 'MergeOrUpload', 'Delete'\n * @readonly\n * @enum {string}\n */\nexport type IndexActionType = 'upload' | 'merge' | 'mergeOrUpload' | 'delete';\n\n/**\n * Defines values for AutocompleteMode.\n * Possible values include: 'OneTerm', 'TwoTerms', 'OneTermWithContext'\n * @readonly\n * @enum {string}\n */\nexport type AutocompleteMode = 'oneTerm' | 'twoTerms' | 'oneTermWithContext';\n\n/**\n * Contains response data for the count operation.\n */\nexport type DocumentsCountResponse = {\n  /**\n   * The parsed response body.\n   */\n  body: number;\n\n  /**\n   * The underlying HTTP response.\n   */\n  _response: coreHttp.HttpResponse & {\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: number;\n    };\n};\n\n/**\n * Contains response data for the searchGet operation.\n */\nexport type DocumentsSearchGetResponse = SearchDocumentsResult & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: coreHttp.HttpResponse & {\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: SearchDocumentsResult;\n    };\n};\n\n/**\n * Contains response data for the searchPost operation.\n */\nexport type DocumentsSearchPostResponse = SearchDocumentsResult & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: coreHttp.HttpResponse & {\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: SearchDocumentsResult;\n    };\n};\n\n/**\n * Contains response data for the get operation.\n */\nexport type DocumentsGetResponse = {\n  /**\n   * The parsed response body.\n   */\n  body: any;\n\n  /**\n   * The underlying HTTP response.\n   */\n  _response: coreHttp.HttpResponse & {\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: any;\n    };\n};\n\n/**\n * Contains response data for the suggestGet operation.\n */\nexport type DocumentsSuggestGetResponse = SuggestDocumentsResult & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: coreHttp.HttpResponse & {\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: SuggestDocumentsResult;\n    };\n};\n\n/**\n * Contains response data for the suggestPost operation.\n */\nexport type DocumentsSuggestPostResponse = SuggestDocumentsResult & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: coreHttp.HttpResponse & {\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: SuggestDocumentsResult;\n    };\n};\n\n/**\n * Contains response data for the index operation.\n */\nexport type DocumentsIndexResponse = IndexDocumentsResult & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: coreHttp.HttpResponse & {\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: IndexDocumentsResult;\n    };\n};\n\n/**\n * Contains response data for the autocompleteGet operation.\n */\nexport type DocumentsAutocompleteGetResponse = AutocompleteResult & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: coreHttp.HttpResponse & {\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: AutocompleteResult;\n    };\n};\n\n/**\n * Contains response data for the autocompletePost operation.\n */\nexport type DocumentsAutocompletePostResponse = AutocompleteResult & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: coreHttp.HttpResponse & {\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: AutocompleteResult;\n    };\n};\n"]}