'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var logger$1 = require('@azure/logger');
var coreTracing = require('@azure/core-tracing');
var api = require('@opentelemetry/api');
var coreAuth = require('@azure/core-auth');

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const SuggestResult = {
    serializedName: "SuggestResult",
    type: {
        name: "Composite",
        className: "SuggestResult",
        modelProperties: {
            _text: {
                required: true,
                readOnly: true,
                serializedName: "@search\\.text",
                type: {
                    name: "String"
                }
            }
        },
        additionalProperties: {
            type: {
                name: "Object"
            }
        }
    }
};
const SuggestDocumentsResult = {
    serializedName: "SuggestDocumentsResult",
    type: {
        name: "Composite",
        className: "SuggestDocumentsResult",
        modelProperties: {
            results: {
                required: true,
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SuggestResult",
                            additionalProperties: {
                                type: {
                                    name: "Object"
                                }
                            }
                        }
                    }
                }
            },
            coverage: {
                readOnly: true,
                serializedName: "@search\\.coverage",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const FacetResult = {
    serializedName: "FacetResult",
    type: {
        name: "Composite",
        className: "FacetResult",
        modelProperties: {
            count: {
                readOnly: true,
                serializedName: "count",
                type: {
                    name: "Number"
                }
            }
        },
        additionalProperties: {
            type: {
                name: "Object"
            }
        }
    }
};
const SearchRequest = {
    serializedName: "SearchRequest",
    type: {
        name: "Composite",
        className: "SearchRequest",
        modelProperties: {
            includeTotalResultCount: {
                serializedName: "count",
                type: {
                    name: "Boolean"
                }
            },
            facets: {
                serializedName: "facets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            highlightFields: {
                serializedName: "highlight",
                type: {
                    name: "String"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            orderBy: {
                serializedName: "orderby",
                type: {
                    name: "String"
                }
            },
            queryType: {
                serializedName: "queryType",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "simple",
                        "full"
                    ]
                }
            },
            scoringParameters: {
                serializedName: "scoringParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            scoringProfile: {
                serializedName: "scoringProfile",
                type: {
                    name: "String"
                }
            },
            searchText: {
                serializedName: "search",
                type: {
                    name: "String"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            searchMode: {
                serializedName: "searchMode",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "any",
                        "all"
                    ]
                }
            },
            select: {
                serializedName: "select",
                type: {
                    name: "String"
                }
            },
            skip: {
                serializedName: "skip",
                type: {
                    name: "Number"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SearchResult = {
    serializedName: "SearchResult",
    type: {
        name: "Composite",
        className: "SearchResult",
        modelProperties: {
            _score: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "@search\\.score",
                type: {
                    name: "Number"
                }
            },
            _highlights: {
                readOnly: true,
                serializedName: "@search\\.highlights",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            }
        },
        additionalProperties: {
            type: {
                name: "Object"
            }
        }
    }
};
const SearchDocumentsResult = {
    serializedName: "SearchDocumentsResult",
    type: {
        name: "Composite",
        className: "SearchDocumentsResult",
        modelProperties: {
            count: {
                readOnly: true,
                serializedName: "@odata\\.count",
                type: {
                    name: "Number"
                }
            },
            coverage: {
                readOnly: true,
                serializedName: "@search\\.coverage",
                type: {
                    name: "Number"
                }
            },
            facets: {
                readOnly: true,
                serializedName: "@search\\.facets",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "FacetResult",
                                    additionalProperties: {
                                        type: {
                                            name: "Object"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },
            nextPageParameters: {
                readOnly: true,
                serializedName: "@search\\.nextPageParameters",
                type: {
                    name: "Composite",
                    className: "SearchRequest"
                }
            },
            results: {
                required: true,
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchResult",
                            additionalProperties: {
                                type: {
                                    name: "Object"
                                }
                            }
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "@odata\\.nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IndexAction = {
    serializedName: "IndexAction",
    type: {
        name: "Composite",
        className: "IndexAction",
        modelProperties: {
            __actionType: {
                required: true,
                nullable: false,
                serializedName: "@search\\.action",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "upload",
                        "merge",
                        "mergeOrUpload",
                        "delete"
                    ]
                }
            }
        },
        additionalProperties: {
            type: {
                name: "Object"
            }
        }
    }
};
const IndexBatch = {
    serializedName: "IndexBatch",
    type: {
        name: "Composite",
        className: "IndexBatch",
        modelProperties: {
            actions: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IndexAction",
                            additionalProperties: {
                                type: {
                                    name: "Object"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
const IndexingResult = {
    serializedName: "IndexingResult",
    type: {
        name: "Composite",
        className: "IndexingResult",
        modelProperties: {
            key: {
                required: true,
                readOnly: true,
                serializedName: "key",
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                readOnly: true,
                serializedName: "errorMessage",
                type: {
                    name: "String"
                }
            },
            succeeded: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "status",
                type: {
                    name: "Boolean"
                }
            },
            statusCode: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "statusCode",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const IndexDocumentsResult = {
    serializedName: "IndexDocumentsResult",
    type: {
        name: "Composite",
        className: "IndexDocumentsResult",
        modelProperties: {
            results: {
                required: true,
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IndexingResult"
                        }
                    }
                }
            }
        }
    }
};
const SuggestRequest = {
    serializedName: "SuggestRequest",
    type: {
        name: "Composite",
        className: "SuggestRequest",
        modelProperties: {
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            useFuzzyMatching: {
                serializedName: "fuzzy",
                type: {
                    name: "Boolean"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            orderBy: {
                serializedName: "orderby",
                type: {
                    name: "String"
                }
            },
            searchText: {
                required: true,
                serializedName: "search",
                type: {
                    name: "String"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            select: {
                serializedName: "select",
                type: {
                    name: "String"
                }
            },
            suggesterName: {
                required: true,
                serializedName: "suggesterName",
                type: {
                    name: "String"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutocompleteRequest = {
    serializedName: "AutocompleteRequest",
    type: {
        name: "Composite",
        className: "AutocompleteRequest",
        modelProperties: {
            searchText: {
                required: true,
                serializedName: "search",
                type: {
                    name: "String"
                }
            },
            autocompleteMode: {
                serializedName: "autocompleteMode",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "oneTerm",
                        "twoTerms",
                        "oneTermWithContext"
                    ]
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            useFuzzyMatching: {
                serializedName: "fuzzy",
                type: {
                    name: "Boolean"
                }
            },
            highlightPostTag: {
                serializedName: "highlightPostTag",
                type: {
                    name: "String"
                }
            },
            highlightPreTag: {
                serializedName: "highlightPreTag",
                type: {
                    name: "String"
                }
            },
            minimumCoverage: {
                serializedName: "minimumCoverage",
                type: {
                    name: "Number"
                }
            },
            searchFields: {
                serializedName: "searchFields",
                type: {
                    name: "String"
                }
            },
            suggesterName: {
                required: true,
                serializedName: "suggesterName",
                type: {
                    name: "String"
                }
            },
            top: {
                serializedName: "top",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutocompleteItem = {
    serializedName: "AutocompleteItem",
    type: {
        name: "Composite",
        className: "AutocompleteItem",
        modelProperties: {
            text: {
                required: true,
                readOnly: true,
                serializedName: "text",
                type: {
                    name: "String"
                }
            },
            queryPlusText: {
                required: true,
                readOnly: true,
                serializedName: "queryPlusText",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutocompleteResult = {
    serializedName: "AutocompleteResult",
    type: {
        name: "Composite",
        className: "AutocompleteResult",
        modelProperties: {
            coverage: {
                readOnly: true,
                serializedName: "@search\\.coverage",
                type: {
                    name: "Number"
                }
            },
            results: {
                required: true,
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutocompleteItem"
                        }
                    }
                }
            }
        }
    }
};
const SearchError = {
    serializedName: "SearchError",
    type: {
        name: "Composite",
        className: "SearchError",
        modelProperties: {
            code: {
                readOnly: true,
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                required: true,
                readOnly: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            details: {
                readOnly: true,
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchError"
                        }
                    }
                }
            }
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AutocompleteItem: AutocompleteItem,
    AutocompleteRequest: AutocompleteRequest,
    AutocompleteResult: AutocompleteResult,
    FacetResult: FacetResult,
    IndexAction: IndexAction,
    IndexBatch: IndexBatch,
    IndexDocumentsResult: IndexDocumentsResult,
    IndexingResult: IndexingResult,
    SearchDocumentsResult: SearchDocumentsResult,
    SearchError: SearchError,
    SearchRequest: SearchRequest,
    SearchResult: SearchResult,
    SuggestDocumentsResult: SuggestDocumentsResult,
    SuggestRequest: SuggestRequest,
    SuggestResult: SuggestResult
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        required: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const autocompleteMode = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "autocompleteMode"
    ],
    mapper: {
        serializedName: "autocompleteMode",
        type: {
            name: "Enum",
            allowedValues: [
                "oneTerm",
                "twoTerms",
                "oneTermWithContext"
            ]
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        required: true,
        serializedName: "endpoint",
        defaultValue: '',
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const facets = {
    parameterPath: [
        "options",
        "searchOptions",
        "facets"
    ],
    mapper: {
        serializedName: "facet",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Multi
};
const filter0 = {
    parameterPath: [
        "options",
        "searchOptions",
        "filter"
    ],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const filter1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "filter"
    ],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const filter2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "filter"
    ],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const highlightFields = {
    parameterPath: [
        "options",
        "searchOptions",
        "highlightFields"
    ],
    mapper: {
        serializedName: "highlight",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const highlightPostTag0 = {
    parameterPath: [
        "options",
        "searchOptions",
        "highlightPostTag"
    ],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPostTag1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "highlightPostTag"
    ],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPostTag2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "highlightPostTag"
    ],
    mapper: {
        serializedName: "highlightPostTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag0 = {
    parameterPath: [
        "options",
        "searchOptions",
        "highlightPreTag"
    ],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "highlightPreTag"
    ],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const highlightPreTag2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "highlightPreTag"
    ],
    mapper: {
        serializedName: "highlightPreTag",
        type: {
            name: "String"
        }
    }
};
const includeTotalResultCount = {
    parameterPath: [
        "options",
        "searchOptions",
        "includeTotalResultCount"
    ],
    mapper: {
        serializedName: "$count",
        type: {
            name: "Boolean"
        }
    }
};
const indexName = {
    parameterPath: "indexName",
    mapper: {
        required: true,
        serializedName: "indexName",
        defaultValue: '',
        type: {
            name: "String"
        }
    }
};
const key = {
    parameterPath: "key",
    mapper: {
        required: true,
        serializedName: "key",
        type: {
            name: "String"
        }
    }
};
const minimumCoverage0 = {
    parameterPath: [
        "options",
        "searchOptions",
        "minimumCoverage"
    ],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const minimumCoverage1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "minimumCoverage"
    ],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const minimumCoverage2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "minimumCoverage"
    ],
    mapper: {
        serializedName: "minimumCoverage",
        type: {
            name: "Number"
        }
    }
};
const orderBy0 = {
    parameterPath: [
        "options",
        "searchOptions",
        "orderBy"
    ],
    mapper: {
        serializedName: "$orderby",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const orderBy1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "orderBy"
    ],
    mapper: {
        serializedName: "$orderby",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const queryType = {
    parameterPath: [
        "options",
        "searchOptions",
        "queryType"
    ],
    mapper: {
        serializedName: "queryType",
        type: {
            name: "Enum",
            allowedValues: [
                "simple",
                "full"
            ]
        }
    }
};
const scoringParameters = {
    parameterPath: [
        "options",
        "searchOptions",
        "scoringParameters"
    ],
    mapper: {
        serializedName: "scoringParameter",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Multi
};
const scoringProfile = {
    parameterPath: [
        "options",
        "searchOptions",
        "scoringProfile"
    ],
    mapper: {
        serializedName: "scoringProfile",
        type: {
            name: "String"
        }
    }
};
const searchFields0 = {
    parameterPath: [
        "options",
        "searchOptions",
        "searchFields"
    ],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const searchFields1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "searchFields"
    ],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const searchFields2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "searchFields"
    ],
    mapper: {
        serializedName: "searchFields",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const searchMode = {
    parameterPath: [
        "options",
        "searchOptions",
        "searchMode"
    ],
    mapper: {
        serializedName: "searchMode",
        type: {
            name: "Enum",
            allowedValues: [
                "any",
                "all"
            ]
        }
    }
};
const searchText0 = {
    parameterPath: [
        "options",
        "searchText"
    ],
    mapper: {
        serializedName: "search",
        type: {
            name: "String"
        }
    }
};
const searchText1 = {
    parameterPath: "searchText",
    mapper: {
        required: true,
        serializedName: "search",
        type: {
            name: "String"
        }
    }
};
const select0 = {
    parameterPath: [
        "options",
        "searchOptions",
        "select"
    ],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const select1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "select"
    ],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const selectedFields = {
    parameterPath: [
        "options",
        "selectedFields"
    ],
    mapper: {
        serializedName: "$select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const skip = {
    parameterPath: [
        "options",
        "searchOptions",
        "skip"
    ],
    mapper: {
        serializedName: "$skip",
        type: {
            name: "Number"
        }
    }
};
const suggesterName = {
    parameterPath: "suggesterName",
    mapper: {
        required: true,
        serializedName: "suggesterName",
        type: {
            name: "String"
        }
    }
};
const top0 = {
    parameterPath: [
        "options",
        "searchOptions",
        "top"
    ],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const top1 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "top"
    ],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const top2 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "top"
    ],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const useFuzzyMatching0 = {
    parameterPath: [
        "options",
        "suggestOptions",
        "useFuzzyMatching"
    ],
    mapper: {
        serializedName: "fuzzy",
        type: {
            name: "Boolean"
        }
    }
};
const useFuzzyMatching1 = {
    parameterPath: [
        "options",
        "autocompleteOptions",
        "useFuzzyMatching"
    ],
    mapper: {
        serializedName: "fuzzy",
        type: {
            name: "Boolean"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a Documents. */
class Documents {
    /**
     * Create a Documents.
     * @param {SearchClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    count(options, callback) {
        return this.client.sendOperationRequest({
            options
        }, countOperationSpec, callback);
    }
    searchGet(options, callback) {
        return this.client.sendOperationRequest({
            options
        }, searchGetOperationSpec, callback);
    }
    searchPost(searchRequest, options, callback) {
        return this.client.sendOperationRequest({
            searchRequest,
            options
        }, searchPostOperationSpec, callback);
    }
    get(key, options, callback) {
        return this.client.sendOperationRequest({
            key,
            options
        }, getOperationSpec, callback);
    }
    suggestGet(searchText, suggesterName, options, callback) {
        return this.client.sendOperationRequest({
            searchText,
            suggesterName,
            options
        }, suggestGetOperationSpec, callback);
    }
    suggestPost(suggestRequest, options, callback) {
        return this.client.sendOperationRequest({
            suggestRequest,
            options
        }, suggestPostOperationSpec, callback);
    }
    index(batch, options, callback) {
        return this.client.sendOperationRequest({
            batch,
            options
        }, indexOperationSpec, callback);
    }
    autocompleteGet(searchText, suggesterName, options, callback) {
        return this.client.sendOperationRequest({
            searchText,
            suggesterName,
            options
        }, autocompleteGetOperationSpec, callback);
    }
    autocompletePost(autocompleteRequest, options, callback) {
        return this.client.sendOperationRequest({
            autocompleteRequest,
            options
        }, autocompletePostOperationSpec, callback);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers);
const countOperationSpec = {
    httpMethod: "GET",
    path: "docs/$count",
    urlParameters: [
        endpoint,
        indexName
    ],
    queryParameters: [
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                    name: "Number"
                }
            }
        },
        default: {
            bodyMapper: SearchError
        }
    },
    serializer
};
const searchGetOperationSpec = {
    httpMethod: "GET",
    path: "docs",
    urlParameters: [
        endpoint,
        indexName
    ],
    queryParameters: [
        searchText0,
        apiVersion,
        includeTotalResultCount,
        facets,
        filter0,
        highlightFields,
        highlightPostTag0,
        highlightPreTag0,
        minimumCoverage0,
        orderBy0,
        queryType,
        scoringParameters,
        scoringProfile,
        searchFields0,
        searchMode,
        select0,
        skip,
        top0
    ],
    responses: {
        200: {
            bodyMapper: SearchDocumentsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    serializer
};
const searchPostOperationSpec = {
    httpMethod: "POST",
    path: "docs/search.post.search",
    urlParameters: [
        endpoint,
        indexName
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: "searchRequest",
        mapper: Object.assign(Object.assign({}, SearchRequest), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SearchDocumentsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    serializer
};
const getOperationSpec = {
    httpMethod: "GET",
    path: "docs('{key}')",
    urlParameters: [
        endpoint,
        indexName,
        key
    ],
    queryParameters: [
        selectedFields,
        apiVersion
    ],
    responses: {
        200: {
            bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                    name: "Object"
                }
            }
        },
        default: {
            bodyMapper: SearchError
        }
    },
    serializer
};
const suggestGetOperationSpec = {
    httpMethod: "GET",
    path: "docs/search.suggest",
    urlParameters: [
        endpoint,
        indexName
    ],
    queryParameters: [
        searchText1,
        suggesterName,
        apiVersion,
        filter1,
        useFuzzyMatching0,
        highlightPostTag1,
        highlightPreTag1,
        minimumCoverage1,
        orderBy1,
        searchFields1,
        select1,
        top1
    ],
    responses: {
        200: {
            bodyMapper: SuggestDocumentsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    serializer
};
const suggestPostOperationSpec = {
    httpMethod: "POST",
    path: "docs/search.post.suggest",
    urlParameters: [
        endpoint,
        indexName
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: "suggestRequest",
        mapper: Object.assign(Object.assign({}, SuggestRequest), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SuggestDocumentsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    serializer
};
const indexOperationSpec = {
    httpMethod: "POST",
    path: "docs/search.index",
    urlParameters: [
        endpoint,
        indexName
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: "batch",
        mapper: Object.assign(Object.assign({}, IndexBatch), { required: true })
    },
    responses: {
        200: {
            bodyMapper: IndexDocumentsResult
        },
        207: {
            bodyMapper: IndexDocumentsResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    serializer
};
const autocompleteGetOperationSpec = {
    httpMethod: "GET",
    path: "docs/search.autocomplete",
    urlParameters: [
        endpoint,
        indexName
    ],
    queryParameters: [
        apiVersion,
        searchText1,
        suggesterName,
        autocompleteMode,
        filter2,
        useFuzzyMatching1,
        highlightPostTag2,
        highlightPreTag2,
        minimumCoverage2,
        searchFields2,
        top2
    ],
    responses: {
        200: {
            bodyMapper: AutocompleteResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    serializer
};
const autocompletePostOperationSpec = {
    httpMethod: "POST",
    path: "docs/search.post.autocomplete",
    urlParameters: [
        endpoint,
        indexName
    ],
    queryParameters: [
        apiVersion
    ],
    requestBody: {
        parameterPath: "autocompleteRequest",
        mapper: Object.assign(Object.assign({}, AutocompleteRequest), { required: true })
    },
    responses: {
        200: {
            bodyMapper: AutocompleteResult
        },
        default: {
            bodyMapper: SearchError
        }
    },
    serializer
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
const packageName = "@azure/search-documents";
const packageVersion = "11.0.3";
class SearchClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the SearchClientContext class.
     * @param apiVersion Client Api Version.
     * @param endpoint The endpoint URL of the search service.
     * @param indexName The name of the index.
     * @param [options] The parameter options
     */
    constructor(apiVersion, endpoint, indexName, options) {
        if (apiVersion == undefined) {
            throw new Error("'apiVersion' cannot be null.");
        }
        if (endpoint == undefined) {
            throw new Error("'endpoint' cannot be null.");
        }
        if (indexName == undefined) {
            throw new Error("'indexName' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.baseUri = "{endpoint}/indexes('{indexName}')";
        this.requestContentType = "application/json; charset=utf-8";
        this.apiVersion = apiVersion;
        this.endpoint = endpoint;
        this.indexName = indexName;
    }
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
class SearchClient extends SearchClientContext {
    /**
     * Initializes a new instance of the SearchClient class.
     * @param apiVersion Client Api Version.
     * @param endpoint The endpoint URL of the search service.
     * @param indexName The name of the index.
     * @param [options] The parameter options
     */
    constructor(apiVersion, endpoint, indexName, options) {
        super(apiVersion, endpoint, indexName, options);
        this.documents = new Documents(this);
    }
}

// Copyright (c) Microsoft Corporation.
const API_KEY_HEADER_NAME = "api-key";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Azure Cognitive Search
 */
function createSearchApiKeyCredentialPolicy(credential) {
    return {
        create: (nextPolicy, options) => {
            return new SearchApiKeyCredentialPolicy(nextPolicy, options, credential);
        }
    };
}
/**
 * A concrete implementation of an AzureKeyCredential policy
 * using the appropriate header for Azure Cognitive Search
 */
class SearchApiKeyCredentialPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, credential) {
        super(nextPolicy, options);
        this.credential = credential;
    }
    sendRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!webResource) {
                throw new Error("webResource cannot be null or undefined");
            }
            webResource.headers.set(API_KEY_HEADER_NAME, this.credential.key);
            return this._nextPolicy.sendRequest(webResource);
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "11.0.3";

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("search");

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @ignore
 * @param name The name of the operation being performed.
 * @param tracingOptions The options for the underlying http request.
 */
function createSpan(operationName, operationOptions) {
    const tracer = coreTracing.getTracer();
    const tracingOptions = operationOptions.tracingOptions || {};
    const spanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { kind: api.SpanKind.INTERNAL });
    const span = tracer.startSpan(`Azure.Search.${operationName}`, spanOptions);
    span.setAttribute("az.namespace", "Microsoft.Search");
    let newSpanOptions = tracingOptions.spanOptions || {};
    if (span.isRecording()) {
        newSpanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { parent: span.context(), attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.Search" }) });
    }
    const newTracingOptions = Object.assign(Object.assign({}, tracingOptions), { spanOptions: newSpanOptions });
    const newOperationOptions = Object.assign(Object.assign({}, operationOptions), { tracingOptions: newTracingOptions });
    return {
        span,
        updatedOptions: newOperationOptions
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const WorldGeodeticSystem1984 = "EPSG:4326"; // See https://epsg.io/4326
/**
 * Represents a geographic point in global coordinates.
 */
class GeographyPoint {
    /**
     * Constructs a new instance of GeographyPoint given
     * the specified coordinates.
     * @param latitude latitude value in decimal
     * @param longitude longitude value in decimal
     */
    constructor(latitude, longitude) {
        this.latitude = latitude;
        this.longitude = longitude;
    }
    /**
     * Used to serialize to a GeoJSON Point.
     */
    toJSON() {
        return {
            type: "Point",
            coordinates: [this.longitude, this.latitude],
            crs: { type: "name", properties: { name: WorldGeodeticSystem1984 } }
        };
    }
}

// Copyright (c) Microsoft Corporation.
const ISO8601DateRegex = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z/i;
const GeoJSONPointTypeName = "Point";
const WorldGeodeticSystem1984$1 = "EPSG:4326"; // See https://epsg.io/4326
function serialize(obj) {
    return walk(obj, (value) => {
        const result = serializeSpecialNumbers(value);
        return result;
    });
}
function deserialize(obj) {
    return walk(obj, (value) => {
        let result = deserializeSpecialNumbers(value);
        result = deserializeDates(result);
        result = deserializeGeoPoint(result);
        return result;
    });
}
function walk(start, mapper) {
    const seenMarker = new WeakMap();
    const result = { value: undefined };
    const queue = [
        { value: start, parent: result, key: "value" }
    ];
    while (queue.length) {
        const current = queue.shift();
        if (typeof current.value === "object" && current.value !== null) {
            if (seenMarker.has(current.value)) {
                throw new Error("Cannot map a recusive structure.");
            }
            else {
                seenMarker.set(current.value, true);
            }
        }
        const mapped = mapper(current.value);
        if ((current === null || current === void 0 ? void 0 : current.parent) && current.key) {
            current.parent[current.key] = mapped;
        }
        if (typeof mapped === "object" && mapped !== null) {
            for (const key of Object.keys(mapped)) {
                queue.push({
                    value: mapped[key],
                    parent: mapped,
                    key
                });
            }
        }
    }
    return result.value;
}
function serializeSpecialNumbers(input) {
    if (typeof input === "number") {
        if (isNaN(input)) {
            return "NaN";
        }
        else if (input === Infinity) {
            return "INF";
        }
        else if (input === -Infinity) {
            return "-INF";
        }
    }
    return input;
}
function deserializeSpecialNumbers(input) {
    if (typeof input === "string") {
        if (input === "NaN") {
            return NaN;
        }
        else if (input === "INF") {
            return Infinity;
        }
        else if (input === "-INF") {
            return -Infinity;
        }
    }
    return input;
}
function deserializeDates(input) {
    if (typeof input === "string") {
        if (ISO8601DateRegex.test(input)) {
            return new Date(input);
        }
    }
    return input;
}
function deserializeGeoPoint(input) {
    if (isGeoJSONPoint(input)) {
        return new GeographyPoint(input.coordinates[0], input.coordinates[1]);
    }
    return input;
}
function isGeoJSONPoint(obj) {
    const requiredKeys = ["type", "coordinates"];
    return isValidObject(obj, {
        requiredKeys,
        propertyValidator: (key) => {
            switch (key) {
                case "type":
                    return obj.type === GeoJSONPointTypeName;
                case "coordinates":
                    return isCoordinateArray(obj.coordinates);
                case "crs":
                    return isCrs(obj.crs);
                default:
                    return false;
            }
        }
    });
}
function isCoordinateArray(maybeCoordinates) {
    if (!Array.isArray(maybeCoordinates)) {
        return false;
    }
    if (maybeCoordinates.length !== 2) {
        return false;
    }
    if (typeof maybeCoordinates[0] !== "number" || typeof maybeCoordinates[1] !== "number") {
        return false;
    }
    return true;
}
function isCrs(maybeCrs) {
    return isValidObject(maybeCrs, {
        requiredKeys: ["type", "properties"],
        propertyValidator: (key) => {
            switch (key) {
                case "type":
                    return maybeCrs.type === "name";
                case "properties":
                    return isCrsProperties(maybeCrs.properties);
                default:
                    return false;
            }
        }
    });
}
function isCrsProperties(maybeProperties) {
    return isValidObject(maybeProperties, {
        requiredKeys: ["name"],
        propertyValidator: (key) => {
            if (key === "name") {
                return maybeProperties.name === WorldGeodeticSystem1984$1;
            }
            else {
                return false;
            }
        }
    });
}
function isValidObject(obj, options = {}) {
    if (typeof obj !== "object" || obj === null) {
        return false;
    }
    const keys = Object.keys(obj);
    if (options.requiredKeys) {
        for (const requiredKey of options.requiredKeys) {
            if (!keys.includes(requiredKey)) {
                return false;
            }
        }
    }
    if (options.propertyValidator) {
        for (const key of keys) {
            if (!options.propertyValidator(key)) {
                return false;
            }
        }
    }
    return true;
}

// Copyright (c) Microsoft Corporation.
const AcceptHeaderName = "Accept";
/**
 * A policy factory for setting the Accept header to ignore odata metadata
 * @internal
 * @ignore
 */
function odataMetadataPolicy(metadataLevel) {
    return {
        create: (nextPolicy, options) => {
            return new OdataMetadataPolicy(nextPolicy, options, { metadataLevel });
        }
    };
}
class OdataMetadataPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, policyOptions) {
        super(nextPolicy, options);
        this.metadataLevel = policyOptions.metadataLevel;
    }
    sendRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            webResource.headers.set(AcceptHeaderName, `application/json;odata.metadata=${this.metadataLevel}`);
            return this._nextPolicy.sendRequest(webResource);
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Class used to perform batch operations
 * with multiple documents to the index.
 */
class IndexDocumentsBatch {
    constructor(actions = []) {
        this.actions = actions;
    }
    /**
     * Upload an array of documents to the index.
     * @param documents The documents to upload.
     */
    upload(documents) {
        const batch = documents.map((doc) => {
            return Object.assign(Object.assign({}, doc), { __actionType: "upload" });
        });
        this.actions.push(...batch);
    }
    /**
     * Update a set of documents in the index.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents The updated documents.
     */
    merge(documents) {
        const batch = documents.map((doc) => {
            return Object.assign(Object.assign({}, doc), { __actionType: "merge" });
        });
        this.actions.push(...batch);
    }
    /**
     * Update a set of documents in the index or uploads them if they don't exist.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents The new/updated documents.
     */
    mergeOrUpload(documents) {
        const batch = documents.map((doc) => {
            return Object.assign(Object.assign({}, doc), { __actionType: "mergeOrUpload" });
        });
        this.actions.push(...batch);
    }
    delete(keyNameOrDocuments, keyValues) {
        if (keyValues) {
            const keyName = keyNameOrDocuments;
            const batch = keyValues.map((keyValue) => {
                return {
                    __actionType: "delete",
                    [keyName]: keyValue
                };
            });
            this.actions.push(...batch);
        }
        else {
            const documents = keyNameOrDocuments;
            const batch = documents.map((document) => {
                return Object.assign({ __actionType: "delete" }, document);
            });
            this.actions.push(...batch);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Encodes a string in base64 format.
 * @param value The string to encode.
 */
function encode(value) {
    return Buffer.from(value).toString("base64");
}
/**
 * Decodes a base64 string into a regular string.
 * @param value The base64 string to decode.
 */
function decode(value) {
    return Buffer.from(value, "base64").toString();
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isComplexField(field) {
    return field.type === "Edm.ComplexType" || field.type === "Collection(Edm.ComplexType)";
}
(function (KnownTokenizerNames) {
    /**
     * Grammar-based tokenizer that is suitable for processing most European-language documents. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicTokenizer.html
     */
    KnownTokenizerNames["Classic"] = "classic";
    /**
     * Tokenizes the input from an edge into n-grams of the given size(s). See
     * https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenizer.html
     */
    KnownTokenizerNames["EdgeNGram"] = "edgeNGram";
    /**
     * Emits the entire input as a single token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/KeywordTokenizer.html
     */
    KnownTokenizerNames["Keyword"] = "keyword_v2";
    /**
     * Divides text at non-letters. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LetterTokenizer.html
     */
    KnownTokenizerNames["Letter"] = "letter";
    /**
     * Divides text at non-letters and converts them to lower case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseTokenizer.html
     */
    KnownTokenizerNames["Lowercase"] = "lowercase";
    /**
     * Divides text using language-specific rules.
     */
    KnownTokenizerNames["MicrosoftLanguageTokenizer"] = "microsoft_language_tokenizer";
    /**
     * Divides text using language-specific rules and reduces words to their base forms.
     */
    KnownTokenizerNames["MicrosoftLanguageStemmingTokenizer"] = "microsoft_language_stemming_tokenizer";
    /**
     * Tokenizes the input into n-grams of the given size(s). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenizer.html
     */
    KnownTokenizerNames["NGram"] = "nGram";
    /**
     * Tokenizer for path-like hierarchies. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/path/PathHierarchyTokenizer.html
     */
    KnownTokenizerNames["PathHierarchy"] = "path_hierarchy_v2";
    /**
     * Tokenizer that uses regex pattern matching to construct distinct tokens. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/pattern/PatternTokenizer.html
     */
    KnownTokenizerNames["Pattern"] = "pattern";
    /**
     * Standard Lucene analyzer; Composed of the standard tokenizer, lowercase filter and stop
     * filter. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/StandardTokenizer.html
     */
    KnownTokenizerNames["Standard"] = "standard_v2";
    /**
     * Tokenizes urls and emails as one token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizer.html
     */
    KnownTokenizerNames["UaxUrlEmail"] = "uax_url_email";
    /**
     * Divides text at whitespace. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/WhitespaceTokenizer.html
     */
    KnownTokenizerNames["Whitespace"] = "whitespace";
})(exports.KnownTokenizerNames || (exports.KnownTokenizerNames = {}));
(function (KnownTokenFilterNames) {
    /**
     * A token filter that applies the Arabic normalizer to normalize the orthography. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ar/ArabicNormalizationFilter.html
     */
    KnownTokenFilterNames["ArabicNormalization"] = "arabic_normalization";
    /**
     * Strips all characters after an apostrophe (including the apostrophe itself). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/tr/ApostropheFilter.html
     */
    KnownTokenFilterNames["Apostrophe"] = "apostrophe";
    /**
     * Converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127
     * ASCII characters (the "Basic Latin" Unicode block) into their ASCII equivalents, if such
     * equivalents exist. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html
     */
    KnownTokenFilterNames["AsciiFolding"] = "asciifolding";
    /**
     * Forms bigrams of CJK terms that are generated from StandardTokenizer. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKBigramFilter.html
     */
    KnownTokenFilterNames["CjkBigram"] = "cjk_bigram";
    /**
     * Normalizes CJK width differences. Folds fullwidth ASCII variants into the equivalent basic
     * Latin, and half-width Katakana variants into the equivalent Kana. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKWidthFilter.html
     */
    KnownTokenFilterNames["CjkWidth"] = "cjk_width";
    /**
     * Removes English possessives, and dots from acronyms. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicFilter.html
     */
    KnownTokenFilterNames["Classic"] = "classic";
    /**
     * Construct bigrams for frequently occurring terms while indexing. Single terms are still
     * indexed too, with bigrams overlaid. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/commongrams/CommonGramsFilter.html
     */
    KnownTokenFilterNames["CommonGram"] = "common_grams";
    /**
     * Generates n-grams of the given size(s) starting from the front or the back of an input token.
     * See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.html
     */
    KnownTokenFilterNames["EdgeNGram"] = "edgeNGram_v2";
    /**
     * Removes elisions. For example, "l'avion" (the plane) will be converted to "avion" (plane). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/util/ElisionFilter.html
     */
    KnownTokenFilterNames["Elision"] = "elision";
    /**
     * Normalizes German characters according to the heuristics of the German2 snowball algorithm.
     * See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/de/GermanNormalizationFilter.html
     */
    KnownTokenFilterNames["GermanNormalization"] = "german_normalization";
    /**
     * Normalizes text in Hindi to remove some differences in spelling variations. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/hi/HindiNormalizationFilter.html
     */
    KnownTokenFilterNames["HindiNormalization"] = "hindi_normalization";
    /**
     * Normalizes the Unicode representation of text in Indian languages. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/in/IndicNormalizationFilter.html
     */
    KnownTokenFilterNames["IndicNormalization"] = "indic_normalization";
    /**
     * Emits each incoming token twice, once as keyword and once as non-keyword. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/KeywordRepeatFilter.html
     */
    KnownTokenFilterNames["KeywordRepeat"] = "keyword_repeat";
    /**
     * A high-performance kstem filter for English. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/en/KStemFilter.html
     */
    KnownTokenFilterNames["KStem"] = "kstem";
    /**
     * Removes words that are too long or too short. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LengthFilter.html
     */
    KnownTokenFilterNames["Length"] = "length";
    /**
     * Limits the number of tokens while indexing. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LimitTokenCountFilter.html
     */
    KnownTokenFilterNames["Limit"] = "limit";
    /**
     * Normalizes token text to lower case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseFilter.htm
     */
    KnownTokenFilterNames["Lowercase"] = "lowercase";
    /**
     * Generates n-grams of the given size(s). See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenFilter.html
     */
    KnownTokenFilterNames["NGram"] = "nGram_v2";
    /**
     * Applies normalization for Persian. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/fa/PersianNormalizationFilter.html
     */
    KnownTokenFilterNames["PersianNormalization"] = "persian_normalization";
    /**
     * Create tokens for phonetic matches. See
     * https://lucene.apache.org/core/4_10_3/analyzers-phonetic/org/apache/lucene/analysis/phonetic/package-tree.html
     */
    KnownTokenFilterNames["Phonetic"] = "phonetic";
    /**
     * Uses the Porter stemming algorithm to transform the token stream. See
     * http://tartarus.org/~martin/PorterStemmer
     */
    KnownTokenFilterNames["PorterStem"] = "porter_stem";
    /**
     * Reverses the token string. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/reverse/ReverseStringFilter.html
     */
    KnownTokenFilterNames["Reverse"] = "reverse";
    /**
     * Normalizes use of the interchangeable Scandinavian characters. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianNormalizationFilter.html
     */
    KnownTokenFilterNames["ScandinavianNormalization"] = "scandinavian_normalization";
    /**
     * Folds Scandinavian characters åÅäæÄÆ-&gt;a and öÖøØ-&gt;o. It also discriminates against use
     * of double vowels aa, ae, ao, oe and oo, leaving just the first one. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianFoldingFilter.html
     */
    KnownTokenFilterNames["ScandinavianFoldingNormalization"] = "scandinavian_folding";
    /**
     * Creates combinations of tokens as a single token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/shingle/ShingleFilter.html
     */
    KnownTokenFilterNames["Shingle"] = "shingle";
    /**
     * A filter that stems words using a Snowball-generated stemmer. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/snowball/SnowballFilter.html
     */
    KnownTokenFilterNames["Snowball"] = "snowball";
    /**
     * Normalizes the Unicode representation of Sorani text. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ckb/SoraniNormalizationFilter.html
     */
    KnownTokenFilterNames["SoraniNormalization"] = "sorani_normalization";
    /**
     * Language specific stemming filter. See
     * https://docs.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search#TokenFilters
     */
    KnownTokenFilterNames["Stemmer"] = "stemmer";
    /**
     * Removes stop words from a token stream. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/StopFilter.html
     */
    KnownTokenFilterNames["Stopwords"] = "stopwords";
    /**
     * Trims leading and trailing whitespace from tokens. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TrimFilter.html
     */
    KnownTokenFilterNames["Trim"] = "trim";
    /**
     * Truncates the terms to a specific length. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TruncateTokenFilter.html
     */
    KnownTokenFilterNames["Truncate"] = "truncate";
    /**
     * Filters out tokens with same text as the previous token. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/RemoveDuplicatesTokenFilter.html
     */
    KnownTokenFilterNames["Unique"] = "unique";
    /**
     * Normalizes token text to upper case. See
     * http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/UpperCaseFilter.html
     */
    KnownTokenFilterNames["Uppercase"] = "uppercase";
    /**
     * Splits words into subwords and performs optional transformations on subword groups.
     */
    KnownTokenFilterNames["WordDelimiter"] = "word_delimiter";
})(exports.KnownTokenFilterNames || (exports.KnownTokenFilterNames = {}));
(function (KnownCharFilterNames) {
    /**
     * A character filter that attempts to strip out HTML constructs. See
     * https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.html
     */
    KnownCharFilterNames["HtmlStrip"] = "html_strip";
})(exports.KnownCharFilterNames || (exports.KnownCharFilterNames = {}));
(function (KnownAnalyzerNames) {
    /**
     * Arabic
     */
    KnownAnalyzerNames["ArMicrosoft"] = "ar.microsoft";
    /**
     * Arabic
     */
    KnownAnalyzerNames["ArLucene"] = "ar.lucene";
    /**
     * Armenian
     */
    KnownAnalyzerNames["HyLucene"] = "hy.lucene";
    /**
     * Bangla
     */
    KnownAnalyzerNames["BnMicrosoft"] = "bn.microsoft";
    /**
     * Basque
     */
    KnownAnalyzerNames["EuLucene"] = "eu.lucene";
    /**
     * Bulgarian
     */
    KnownAnalyzerNames["BgMicrosoft"] = "bg.microsoft";
    /**
     * Bulgarian
     */
    KnownAnalyzerNames["BgLucene"] = "bg.lucene";
    /**
     * Catalan
     */
    KnownAnalyzerNames["CaMicrosoft"] = "ca.microsoft";
    /**
     * Catalan
     */
    KnownAnalyzerNames["CaLucene"] = "ca.lucene";
    /**
     * Chinese Simplified
     */
    KnownAnalyzerNames["ZhHansMicrosoft"] = "zh-Hans.microsoft";
    /**
     * Chinese Simplified
     */
    KnownAnalyzerNames["ZhHansLucene"] = "zh-Hans.lucene";
    /**
     * Chinese Traditional
     */
    KnownAnalyzerNames["ZhHantMicrosoft"] = "zh-Hant.microsoft";
    /**
     * Chinese Traditional
     */
    KnownAnalyzerNames["ZhHantLucene"] = "zh-Hant.lucene";
    /**
     * Croatian
     */
    KnownAnalyzerNames["HrMicrosoft"] = "hr.microsoft";
    /**
     * Czech
     */
    KnownAnalyzerNames["CsMicrosoft"] = "cs.microsoft";
    /**
     * Czech
     */
    KnownAnalyzerNames["CsLucene"] = "cs.lucene";
    /**
     * Danish
     */
    KnownAnalyzerNames["DaMicrosoft"] = "da.microsoft";
    /**
     * Danish
     */
    KnownAnalyzerNames["DaLucene"] = "da.lucene";
    /**
     * Dutch
     */
    KnownAnalyzerNames["NlMicrosoft"] = "nl.microsoft";
    /**
     * Dutch
     */
    KnownAnalyzerNames["NlLucene"] = "nl.lucene";
    /**
     * English
     */
    KnownAnalyzerNames["EnMicrosoft"] = "en.microsoft";
    /**
     * English
     */
    KnownAnalyzerNames["EnLucene"] = "en.lucene";
    /**
     * Estonian
     */
    KnownAnalyzerNames["EtMicrosoft"] = "et.microsoft";
    /**
     * Finnish
     */
    KnownAnalyzerNames["FiMicrosoft"] = "fi.microsoft";
    /**
     * Finnish
     */
    KnownAnalyzerNames["FiLucene"] = "fi.lucene";
    /**
     * French
     */
    KnownAnalyzerNames["FrMicrosoft"] = "fr.microsoft";
    /**
     * French
     */
    KnownAnalyzerNames["FrLucene"] = "fr.lucene";
    /**
     * Galician
     */
    KnownAnalyzerNames["GlLucene"] = "gl.lucene";
    /**
     * German
     */
    KnownAnalyzerNames["DeMicrosoft"] = "de.microsoft";
    /**
     * German
     */
    KnownAnalyzerNames["DeLucene"] = "de.lucene";
    /**
     * Greek
     */
    KnownAnalyzerNames["ElMicrosoft"] = "el.microsoft";
    /**
     * Greek
     */
    KnownAnalyzerNames["ElLucene"] = "el.lucene";
    /**
     * Gujarati
     */
    KnownAnalyzerNames["GuMicrosoft"] = "gu.microsoft";
    /**
     * Hebrew
     */
    KnownAnalyzerNames["HeMicrosoft"] = "he.microsoft";
    /**
     * Hindi
     */
    KnownAnalyzerNames["HiMicrosoft"] = "hi.microsoft";
    /**
     * Hindi
     */
    KnownAnalyzerNames["HiLucene"] = "hi.lucene";
    /**
     * Hungarian
     */
    KnownAnalyzerNames["HuMicrosoft"] = "hu.microsoft";
    /**
     * Hungarian
     */
    KnownAnalyzerNames["HuLucene"] = "hu.lucene";
    /**
     * Icelandic
     */
    KnownAnalyzerNames["IsMicrosoft"] = "is.microsoft";
    /**
     * Indonesian (Bahasa)
     */
    KnownAnalyzerNames["IdMicrosoft"] = "id.microsoft";
    /**
     * Indonesian (Bahasa)
     */
    KnownAnalyzerNames["IdLucene"] = "id.lucene";
    /**
     * Irish
     */
    KnownAnalyzerNames["GaLucene"] = "ga.lucene";
    /**
     * Italian
     */
    KnownAnalyzerNames["ItMicrosoft"] = "it.microsoft";
    /**
     * Italian
     */
    KnownAnalyzerNames["ItLucene"] = "it.lucene";
    /**
     * Japanese
     */
    KnownAnalyzerNames["JaMicrosoft"] = "ja.microsoft";
    /**
     * Japanese
     */
    KnownAnalyzerNames["JaLucene"] = "ja.lucene";
    /**
     * Kannada
     */
    KnownAnalyzerNames["KnMicrosoft"] = "kn.microsoft";
    /**
     * Korean
     */
    KnownAnalyzerNames["KoMicrosoft"] = "ko.microsoft";
    /**
     * Korean
     */
    KnownAnalyzerNames["KoLucene"] = "ko.lucene";
    /**
     * Latvian
     */
    KnownAnalyzerNames["LvMicrosoft"] = "lv.microsoft";
    /**
     * Latvian
     */
    KnownAnalyzerNames["LvLucene"] = "lv.lucene";
    /**
     * Lithuanian
     */
    KnownAnalyzerNames["LtMicrosoft"] = "lt.microsoft";
    /**
     * Malayalam
     */
    KnownAnalyzerNames["MlMicrosoft"] = "ml.microsoft";
    /**
     * Malay (Latin)
     */
    KnownAnalyzerNames["MsMicrosoft"] = "ms.microsoft";
    /**
     * Marathi
     */
    KnownAnalyzerNames["MrMicrosoft"] = "mr.microsoft";
    /**
     * Norwegian
     */
    KnownAnalyzerNames["NbMicrosoft"] = "nb.microsoft";
    /**
     * Norwegian
     */
    KnownAnalyzerNames["NoLucene"] = "no.lucene";
    /**
     * Persian
     */
    KnownAnalyzerNames["FaLucene"] = "fa.lucene";
    /**
     * Polish
     */
    KnownAnalyzerNames["PlMicrosoft"] = "pl.microsoft";
    /**
     * Polish
     */
    KnownAnalyzerNames["PlLucene"] = "pl.lucene";
    /**
     * Portuguese (Brazil)
     */
    KnownAnalyzerNames["PtBRMicrosoft"] = "pt-BR.microsoft";
    /**
     * Portuguese (Brazil)
     */
    KnownAnalyzerNames["PtBRLucene"] = "pt-BR.lucene";
    /**
     * Portuguese (Portugal)
     */
    KnownAnalyzerNames["PtPTMicrosoft"] = "pt-PT.microsoft";
    /**
     * Portuguese (Portugal)
     */
    KnownAnalyzerNames["PtPTLucene"] = "pt-PT.lucene";
    /**
     * Punjabi
     */ KnownAnalyzerNames["PaMicrosoft"] = "pa.microsoft";
    /**
     * Romanian
     */
    KnownAnalyzerNames["RoMicrosoft"] = "ro.microsoft";
    /**
     * Romanian
     */
    KnownAnalyzerNames["RoLucene"] = "ro.lucene";
    /**
     * Russian
     */
    KnownAnalyzerNames["RuMicrosoft"] = "ru.microsoft";
    /**
     * Russian
     */
    KnownAnalyzerNames["RuLucene"] = "ru.lucene";
    /**
     * Serbian (Cyrillic)
     */
    KnownAnalyzerNames["SrCyrillicMicrosoft"] = "sr-cyrillic.microsoft";
    /**
     * Serbian (Latin)
     */
    KnownAnalyzerNames["SrLatinMicrosoft"] = "sr-latin.microsoft";
    /**
     * Slovak
     */
    KnownAnalyzerNames["SkMicrosoft"] = "sk.microsoft";
    /**
     * Slovenian
     */
    KnownAnalyzerNames["SlMicrosoft"] = "sl.microsoft";
    /**
     * Spanish
     */
    KnownAnalyzerNames["EsMicrosoft"] = "es.microsoft";
    /**
     * Spanish
     */
    KnownAnalyzerNames["EsLucene"] = "es.lucene";
    /**
     * Swedish
     */
    KnownAnalyzerNames["SvMicrosoft"] = "sv.microsoft";
    /**
     * Swedish
     */
    KnownAnalyzerNames["SvLucene"] = "sv.lucene";
    /**
     * Tamil
     */
    KnownAnalyzerNames["TaMicrosoft"] = "ta.microsoft";
    /**
     * Telugu
     */
    KnownAnalyzerNames["TeMicrosoft"] = "te.microsoft";
    /**
     * Thai
     */
    KnownAnalyzerNames["ThMicrosoft"] = "th.microsoft";
    /**
     * Thai
     */
    KnownAnalyzerNames["ThLucene"] = "th.lucene";
    /**
     * Turkish
     */
    KnownAnalyzerNames["TrMicrosoft"] = "tr.microsoft";
    /**
     * Turkish
     */
    KnownAnalyzerNames["TrLucene"] = "tr.lucene";
    /**
     * Ukrainian
     */
    KnownAnalyzerNames["UkMicrosoft"] = "uk.microsoft";
    /**
     * Urdu
     */
    KnownAnalyzerNames["UrMicrosoft"] = "ur.microsoft";
    /**
     * Vietnamese
     */
    KnownAnalyzerNames["ViMicrosoft"] = "vi.microsoft";
    /**
     * See: https://lucene.apache.org/core/6_6_1/core/org/apache/lucene/analysis/standard/StandardAnalyzer.html
     */
    KnownAnalyzerNames["StandardLucene"] = "standard.lucene";
    /**
     * See https://lucene.apache.org/core/6_6_1/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html
     */
    KnownAnalyzerNames["StandardAsciiFoldingLucene"] = "standardasciifolding.lucene";
    /**
     * Treats the entire content of a field as a single token. This is useful for data like zip codes, ids, and some product names.
     */
    KnownAnalyzerNames["Keyword"] = "keyword";
    /**
     * Flexibly separates text into terms via a regular expression pattern.
     */
    KnownAnalyzerNames["Pattern"] = "pattern";
    /**
     * Divides text at non-letters and converts them to lower case.
     */
    KnownAnalyzerNames["Simple"] = "simple";
    /**
     * Divides text at non-letters; Applies the lowercase and stopword token filters.
     */
    KnownAnalyzerNames["Stop"] = "stop";
    /**
     * An analyzer that uses the whitespace tokenizer.
     */
    KnownAnalyzerNames["Whitespace"] = "whitespace";
})(exports.KnownAnalyzerNames || (exports.KnownAnalyzerNames = {}));
// END manually modified generated interfaces

// Copyright (c) Microsoft Corporation.
function convertSkillsToPublic(skills) {
    if (!skills) {
        return skills;
    }
    const result = [];
    for (const skill of skills) {
        if (skill.odatatype !== "SearchIndexerSkill") {
            result.push(skill);
        }
    }
    return result;
}
function convertCognitiveServicesAccountToGenerated(cognitiveServicesAccount) {
    if (!cognitiveServicesAccount) {
        return cognitiveServicesAccount;
    }
    return cognitiveServicesAccount;
}
function convertCognitiveServicesAccountToPublic(cognitiveServicesAccount) {
    if (!cognitiveServicesAccount) {
        return cognitiveServicesAccount;
    }
    if (cognitiveServicesAccount.odatatype === "#Microsoft.Azure.Search.DefaultCognitiveServices") {
        return cognitiveServicesAccount;
    }
    else {
        return cognitiveServicesAccount;
    }
}
function convertTokenFiltersToGenerated(tokenFilters) {
    if (!tokenFilters) {
        return tokenFilters;
    }
    const result = [];
    for (const filter of tokenFilters) {
        result.push(filter);
    }
    return result;
}
function convertAnalyzersToGenerated(analyzers) {
    if (!analyzers) {
        return analyzers;
    }
    const result = [];
    for (const analyzer of analyzers) {
        switch (analyzer.odatatype) {
            case "#Microsoft.Azure.Search.StandardAnalyzer":
            case "#Microsoft.Azure.Search.StopAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.PatternAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { flags: analyzer.flags ? analyzer.flags.join("|") : undefined }));
                break;
            case "#Microsoft.Azure.Search.CustomAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { tokenizer: analyzer.tokenizerName }));
                break;
        }
    }
    return result;
}
function convertAnalyzersToPublic(analyzers) {
    if (!analyzers) {
        return analyzers;
    }
    const result = [];
    for (const analyzer of analyzers) {
        switch (analyzer.odatatype) {
            case "#Microsoft.Azure.Search.StandardAnalyzer":
            case "#Microsoft.Azure.Search.StopAnalyzer":
                result.push(analyzer);
                break;
            case "#Microsoft.Azure.Search.PatternAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { flags: analyzer.flags ? analyzer.flags.split("|") : undefined }));
                break;
            case "#Microsoft.Azure.Search.CustomAnalyzer":
                result.push(Object.assign(Object.assign({}, analyzer), { tokenizerName: analyzer.tokenizer }));
                break;
        }
    }
    return result;
}
function convertFieldsToPublic(fields) {
    if (!fields) {
        return fields;
    }
    return fields.map((field) => {
        let result;
        if (field.type === "Collection(Edm.ComplexType)" || field.type === "Edm.ComplexType") {
            result = field;
        }
        else {
            const anayzerName = field.analyzer;
            const searchAnalyzerName = field.searchAnalyzer;
            const indexAnalyzerName = field.indexAnalyzer;
            const synonymMapNames = field.synonymMaps;
            const { retrievable } = field, restField = tslib.__rest(field, ["retrievable"]);
            const hidden = typeof retrievable === "boolean" ? !retrievable : retrievable;
            result = Object.assign(Object.assign({}, restField), { hidden,
                anayzerName,
                searchAnalyzerName,
                indexAnalyzerName,
                synonymMapNames });
        }
        return result;
    });
}
function convertFieldsToGenerated(fields) {
    return fields.map((field) => {
        var _a, _b, _c, _d;
        if (isComplexField(field)) {
            return field;
        }
        else {
            const { hidden } = field, restField = tslib.__rest(field, ["hidden"]);
            const retrievable = typeof hidden === "boolean" ? !hidden : hidden;
            return Object.assign(Object.assign({}, restField), { retrievable, 
                // modify API defaults to use less storage for simple types
                searchable: (_a = field.searchable) !== null && _a !== void 0 ? _a : false, filterable: (_b = field.filterable) !== null && _b !== void 0 ? _b : false, facetable: (_c = field.facetable) !== null && _c !== void 0 ? _c : false, sortable: (_d = field.sortable) !== null && _d !== void 0 ? _d : false, analyzer: field.analyzerName, searchAnalyzer: field.searchAnalyzerName, indexAnalyzer: field.indexAnalyzerName, synonymMaps: field.synonymMapNames });
        }
    });
}
function convertTokenizersToGenerated(tokenizers) {
    if (!tokenizers) {
        return tokenizers;
    }
    const result = [];
    for (const tokenizer of tokenizers) {
        if (tokenizer.odatatype === "#Microsoft.Azure.Search.PatternTokenizer") {
            result.push(Object.assign(Object.assign({}, tokenizer), { flags: tokenizer.flags ? tokenizer.flags.join("|") : undefined }));
        }
        else {
            result.push(tokenizer);
        }
    }
    return result;
}
function convertTokenizersToPublic(tokenizers) {
    if (!tokenizers) {
        return tokenizers;
    }
    const result = [];
    for (const tokenizer of tokenizers) {
        if (tokenizer.odatatype === "#Microsoft.Azure.Search.PatternTokenizer") {
            result.push(Object.assign(Object.assign({}, tokenizer), { flags: tokenizer.flags ? tokenizer.flags.split("|") : undefined }));
        }
        else if (tokenizer.odatatype !== "LexicalTokenizer") {
            result.push(tokenizer);
        }
    }
    return result;
}
function convertSimilarityToGenerated(similarity) {
    if (!similarity) {
        return similarity;
    }
    return similarity;
}
function convertSimilarityToPublic(similarity) {
    if (!similarity) {
        return similarity;
    }
    if (similarity.odatatype == "#Microsoft.Azure.Search.ClassicSimilarity") {
        return similarity;
    }
    else {
        return similarity;
    }
}
function extractOperationOptions(obj) {
    const { abortSignal, requestOptions, tracingOptions } = obj, restOptions = tslib.__rest(obj, ["abortSignal", "requestOptions", "tracingOptions"]);
    return {
        operationOptions: {
            abortSignal,
            requestOptions,
            tracingOptions
        },
        restOptions
    };
}
function convertEncryptionKeyToPublic(encryptionKey) {
    if (!encryptionKey) {
        return encryptionKey;
    }
    const result = {
        keyName: encryptionKey.keyName,
        keyVersion: encryptionKey.keyVersion,
        vaultUrl: encryptionKey.vaultUri
    };
    if (encryptionKey.accessCredentials) {
        result.applicationId = encryptionKey.accessCredentials.applicationId;
        result.applicationSecret = encryptionKey.accessCredentials.applicationSecret;
    }
    return result;
}
function convertEncryptionKeyToGenerated(encryptionKey) {
    if (!encryptionKey) {
        return encryptionKey;
    }
    const result = {
        keyName: encryptionKey.keyName,
        keyVersion: encryptionKey.keyVersion,
        vaultUri: encryptionKey.vaultUrl
    };
    if (encryptionKey.applicationId) {
        result.accessCredentials = {
            applicationId: encryptionKey.applicationId,
            applicationSecret: encryptionKey.applicationSecret
        };
    }
    return result;
}
function generatedIndexToPublicIndex(generatedIndex) {
    return {
        name: generatedIndex.name,
        defaultScoringProfile: generatedIndex.defaultScoringProfile,
        corsOptions: generatedIndex.corsOptions,
        suggesters: generatedIndex.suggesters,
        encryptionKey: convertEncryptionKeyToPublic(generatedIndex.encryptionKey),
        etag: generatedIndex.etag,
        analyzers: convertAnalyzersToPublic(generatedIndex.analyzers),
        tokenizers: convertTokenizersToPublic(generatedIndex.tokenizers),
        tokenFilters: generatedIndex.tokenFilters,
        charFilters: generatedIndex.charFilters,
        scoringProfiles: generatedIndex.scoringProfiles,
        fields: convertFieldsToPublic(generatedIndex.fields),
        similarity: convertSimilarityToPublic(generatedIndex.similarity)
    };
}
function generatedSearchResultToPublicSearchResult(results) {
    const returnValues = results.map((result) => {
        const { _score, _highlights } = result, restProps = tslib.__rest(result, ["_score", "_highlights"]);
        const doc = Object.assign({}, restProps);
        const obj = {
            score: _score,
            highlights: _highlights,
            document: doc
        };
        return obj;
    });
    return returnValues;
}
function generatedSuggestDocumentsResultToPublicSuggestDocumentsResult(searchDocumentsResult) {
    const results = searchDocumentsResult.results.map((element) => {
        const { _text } = element, restProps = tslib.__rest(element, ["_text"]);
        const doc = Object.assign({}, restProps);
        const obj = {
            text: _text,
            document: doc
        };
        return obj;
    });
    const result = {
        results: results,
        coverage: searchDocumentsResult.coverage
    };
    return result;
}
function publicIndexToGeneratedIndex(index) {
    return {
        name: index.name,
        defaultScoringProfile: index.defaultScoringProfile,
        corsOptions: index.corsOptions,
        suggesters: index.suggesters,
        encryptionKey: convertEncryptionKeyToGenerated(index.encryptionKey),
        etag: index.etag,
        tokenFilters: convertTokenFiltersToGenerated(index.tokenFilters),
        charFilters: index.charFilters,
        scoringProfiles: index.scoringProfiles,
        analyzers: convertAnalyzersToGenerated(index.analyzers),
        tokenizers: convertTokenizersToGenerated(index.tokenizers),
        fields: convertFieldsToGenerated(index.fields),
        similarity: convertSimilarityToGenerated(index.similarity)
    };
}
function generatedSkillsetToPublicSkillset(generatedSkillset) {
    return {
        name: generatedSkillset.name,
        description: generatedSkillset.description,
        skills: convertSkillsToPublic(generatedSkillset.skills),
        cognitiveServicesAccount: convertCognitiveServicesAccountToPublic(generatedSkillset.cognitiveServicesAccount),
        etag: generatedSkillset.etag
    };
}
function publicSkillsetToGeneratedSkillset(skillset) {
    return {
        name: skillset.name,
        description: skillset.description,
        etag: skillset.etag,
        skills: skillset.skills,
        cognitiveServicesAccount: convertCognitiveServicesAccountToGenerated(skillset.cognitiveServicesAccount)
    };
}
function generatedSynonymMapToPublicSynonymMap(synonymMap) {
    const result = {
        name: synonymMap.name,
        encryptionKey: convertEncryptionKeyToPublic(synonymMap.encryptionKey),
        etag: synonymMap.etag,
        synonyms: []
    };
    if (synonymMap.synonyms) {
        result.synonyms = synonymMap.synonyms.split("\n");
    }
    return result;
}
function publicSynonymMapToGeneratedSynonymMap(synonymMap) {
    const result = {
        name: synonymMap.name,
        encryptionKey: convertEncryptionKeyToGenerated(synonymMap.encryptionKey),
        etag: synonymMap.etag,
        synonyms: synonymMap.synonyms.join("\n")
    };
    result.encryptionKey = convertEncryptionKeyToGenerated(synonymMap.encryptionKey);
    return result;
}
function generatedDataSourceToPublicDataSource(dataSource) {
    return {
        name: dataSource.name,
        description: dataSource.name,
        type: dataSource.type,
        connectionString: dataSource.credentials.connectionString,
        container: dataSource.container,
        etag: dataSource.etag,
        dataChangeDetectionPolicy: convertDataChangeDetectionPolicyToPublic(dataSource.dataChangeDetectionPolicy),
        dataDeletionDetectionPolicy: convertDataDeletionDetectionPolicyToPublic(dataSource.dataDeletionDetectionPolicy)
    };
}
function convertDataChangeDetectionPolicyToPublic(dataChangeDetectionPolicy) {
    if (!dataChangeDetectionPolicy) {
        return dataChangeDetectionPolicy;
    }
    if (dataChangeDetectionPolicy.odatatype ===
        "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy") {
        return dataChangeDetectionPolicy;
    }
    else {
        return dataChangeDetectionPolicy;
    }
}
function convertDataDeletionDetectionPolicyToPublic(dataDeletionDetectionPolicy) {
    if (!dataDeletionDetectionPolicy) {
        return dataDeletionDetectionPolicy;
    }
    return dataDeletionDetectionPolicy;
}

// Copyright (c) Microsoft Corporation.
/**
 * Class used to perform operations against a search index,
 * including querying documents in the index as well as
 * adding, updating, and removing them.
 */
class SearchClient$1 {
    /**
     * Creates an instance of SearchClient.
     *
     * Example usage:
     * ```ts
     * const { SearchClient, AzureKeyCredential } = require("@azure/search-documents");
     *
     * const client = new SearchClient(
     *   "<endpoint>",
     *   "<indexName>",
     *   new AzureKeyCredential("<Admin Key>");
     * );
     * ```
     * @param {string} endpoint The endpoint of the search service
     * @param {string} indexName The name of the index
     * @param {KeyCredential} credential Used to authenticate requests to the service.
     * @param {SearchClientOptions} [options] Used to configure the Search client.
     */
    constructor(endpoint, indexName, credential, options = {}) {
        /// Maintenance note: when updating supported API versions,
        /// the ContinuationToken logic will need to be updated below.
        /**
         * The API version to use when communicating with the service.
         */
        this.apiVersion = "2020-06-30";
        this.endpoint = endpoint;
        this.indexName = indexName;
        const libInfo = `azsdk-js-search-documents/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        if (options.userAgentOptions.userAgentPrefix) {
            options.userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            options.userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: [
                    "elapsed-time",
                    "Location",
                    "OData-MaxVersion",
                    "OData-Version",
                    "Prefer",
                    "throttle-reason"
                ]
            }
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, createSearchApiKeyCredentialPolicy(credential));
        if (Array.isArray(pipeline.requestPolicyFactories)) {
            pipeline.requestPolicyFactories.unshift(odataMetadataPolicy("none"));
        }
        this.client = new SearchClient(this.apiVersion, this.endpoint, this.indexName, pipeline);
    }
    /**
     * Retrieves the number of documents in the index.
     * @param options Options to the count operation.
     */
    getDocumentsCount(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchClient-getDocumentsCount", options);
            try {
                const result = yield this.client.documents.count(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return Number(result._response.bodyAsText);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Based on a partial searchText from the user, return a list
     * of potential completion strings based on a specified suggester.
     * @param searchText The search text on which to base autocomplete results.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index definition.
     * @param options Options to the autocomplete operation.
     */
    autocomplete(searchText, suggesterName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { operationOptions, restOptions } = this.extractOperationOptions(Object.assign({}, options));
            const { searchFields } = restOptions, nonFieldOptions = tslib.__rest(restOptions, ["searchFields"]);
            const fullOptions = Object.assign({ searchText: searchText, suggesterName: suggesterName, searchFields: this.convertSearchFields(searchFields) }, nonFieldOptions);
            if (!fullOptions.searchText) {
                throw new RangeError("searchText must be provided.");
            }
            if (!fullOptions.suggesterName) {
                throw new RangeError("suggesterName must be provided.");
            }
            const { span, updatedOptions } = createSpan("SearchClient-autocomplete", operationOptions);
            try {
                const result = yield this.client.documents.autocompletePost(fullOptions, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    searchDocuments(searchText, options = {}, nextPageParameters = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { operationOptions, restOptions } = this.extractOperationOptions(Object.assign({}, options));
            const { select, searchFields, orderBy } = restOptions, nonFieldOptions = tslib.__rest(restOptions, ["select", "searchFields", "orderBy"]);
            const fullOptions = Object.assign(Object.assign({ searchFields: this.convertSearchFields(searchFields), select: this.convertSelect(select), orderBy: this.convertOrderBy(orderBy) }, nonFieldOptions), nextPageParameters);
            const { span, updatedOptions } = createSpan("SearchClient-searchDocuments", operationOptions);
            try {
                const result = yield this.client.documents.searchPost(Object.assign(Object.assign({}, fullOptions), { includeTotalResultCount: fullOptions.includeTotalCount, searchText: searchText }), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                const { results, count, coverage, facets, nextLink, nextPageParameters } = result;
                let modifiedResults = generatedSearchResultToPublicSearchResult(results);
                const converted = {
                    results: modifiedResults,
                    count,
                    coverage,
                    facets,
                    continuationToken: this.encodeContinuationToken(nextLink, nextPageParameters)
                };
                return deserialize(converted);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listSearchResultsPage(searchText, options = {}, settings = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSearchResultsPage_1() {
            const decodedContinuation = this.decodeContinuationToken(settings.continuationToken);
            let result = yield tslib.__await(this.searchDocuments(searchText, options, decodedContinuation === null || decodedContinuation === void 0 ? void 0 : decodedContinuation.nextPageParameters));
            yield yield tslib.__await(result);
            // Technically, we should also leverage nextLink, but the generated code
            // doesn't support this yet.
            while (result.continuationToken) {
                const decodedContinuation = this.decodeContinuationToken(result.continuationToken);
                result = yield tslib.__await(this.searchDocuments(searchText, options, decodedContinuation === null || decodedContinuation === void 0 ? void 0 : decodedContinuation.nextPageParameters));
                yield yield tslib.__await(result);
            }
        });
    }
    listSearchResultsAll(firstPage, searchText, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSearchResultsAll_1() {
            var e_1, _a;
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(firstPage.results)));
            if (firstPage.continuationToken) {
                try {
                    for (var _b = tslib.__asyncValues(this.listSearchResultsPage(searchText, options, {
                        continuationToken: firstPage.continuationToken
                    })), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                        const page = _c.value;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page.results)));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        });
    }
    listSearchResults(firstPage, searchText, options = {}) {
        const iter = this.listSearchResultsAll(firstPage, searchText, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                return this.listSearchResultsPage(searchText, options, settings);
            }
        };
    }
    /**
     * Performs a search on the current index given
     * the specified arguments.
     * @param searchText Text to search
     * @param options Options for the search operation.
     */
    search(searchText, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchClient-search", options);
            try {
                const pageResult = yield this.searchDocuments(searchText, updatedOptions);
                const { count, coverage, facets } = pageResult;
                return {
                    count,
                    coverage,
                    facets,
                    results: this.listSearchResults(pageResult, searchText, updatedOptions)
                };
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns a short list of suggestions based on the searchText
     * and specified suggester.
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and no more than 100 characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part of the index definition.
     * @param options Options for the suggest operation
     */
    suggest(searchText, suggesterName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { operationOptions, restOptions } = this.extractOperationOptions(Object.assign({}, options));
            const { select, searchFields, orderBy } = restOptions, nonFieldOptions = tslib.__rest(restOptions, ["select", "searchFields", "orderBy"]);
            const fullOptions = Object.assign({ searchText: searchText, suggesterName: suggesterName, searchFields: this.convertSearchFields(searchFields), select: this.convertSelect(select), orderBy: this.convertOrderBy(orderBy) }, nonFieldOptions);
            if (!fullOptions.searchText) {
                throw new RangeError("searchText must be provided.");
            }
            if (!fullOptions.suggesterName) {
                throw new RangeError("suggesterName must be provided.");
            }
            const { span, updatedOptions } = createSpan("SearchClient-suggest", operationOptions);
            try {
                const result = yield this.client.documents.suggestPost(fullOptions, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                const modifiedResult = generatedSuggestDocumentsResultToPublicSuggestDocumentsResult(result);
                return deserialize(modifiedResult);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieve a particular document from the index by key.
     * @param key The primary key value of the document
     * @param options Additional options
     */
    getDocument(key, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchClient-getDocument", options);
            try {
                const result = yield this.client.documents.get(key, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return deserialize(result.body);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Perform a set of index modifications (upload, merge, mergeOrUpload, delete)
     * for the given set of documents.
     * This operation may partially succeed and not all document operations will
     * be reflected in the index. If you would like to treat this as an exception,
     * set the `throwOnAnyFailure` option to true.
     * For more details about how merging works, see: https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param batch An array of actions to perform on the index.
     * @param options Additional options.
     */
    indexDocuments(
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    batch, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchClient-indexDocuments", options);
            try {
                const result = yield this.client.documents.index({ actions: serialize(batch.actions) }, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                if (options.throwOnAnyFailure && result._response.status === 207) {
                    throw result;
                }
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Upload an array of documents to the index.
     * @param documents The documents to upload.
     * @param options Additional options.
     */
    uploadDocuments(documents, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchClient-uploadDocuments", options);
            const batch = new IndexDocumentsBatch();
            batch.upload(documents);
            try {
                return yield this.indexDocuments(batch, updatedOptions);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Update a set of documents in the index.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents The updated documents.
     * @param options Additional options.
     */
    mergeDocuments(documents, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchClient-mergeDocuments", options);
            const batch = new IndexDocumentsBatch();
            batch.merge(documents);
            try {
                return yield this.indexDocuments(batch, updatedOptions);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Update a set of documents in the index or upload them if they don't exist.
     * For more details about how merging works, see https://docs.microsoft.com/en-us/rest/api/searchservice/AddUpdate-or-Delete-Documents
     * @param documents The updated documents.
     * @param options Additional options.
     */
    mergeOrUploadDocuments(documents, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchClient-mergeDocuments", options);
            const batch = new IndexDocumentsBatch();
            batch.mergeOrUpload(documents);
            try {
                return yield this.indexDocuments(batch, updatedOptions);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    deleteDocuments(keyNameOrDocuments, keyValuesOrOptions, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchClient-deleteDocuments", options);
            const batch = new IndexDocumentsBatch();
            if (typeof keyNameOrDocuments === "string") {
                batch.delete(keyNameOrDocuments, keyValuesOrOptions);
            }
            else {
                batch.delete(keyNameOrDocuments);
            }
            try {
                return yield this.indexDocuments(batch, updatedOptions);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    encodeContinuationToken(nextLink, nextPageParameters) {
        if (!nextLink || !nextPageParameters) {
            return undefined;
        }
        const payload = JSON.stringify({
            apiVersion: this.apiVersion,
            nextLink,
            nextPageParameters
        });
        return encode(payload);
    }
    decodeContinuationToken(token) {
        if (!token) {
            return undefined;
        }
        const decodedToken = decode(token);
        try {
            const result = JSON.parse(decodedToken);
            if (result.apiVersion !== this.apiVersion) {
                throw new RangeError(`Continuation token uses unsupported apiVersion "${this.apiVersion}"`);
            }
            return {
                nextLink: result.nextLink,
                nextPageParameters: result.nextPageParameters
            };
        }
        catch (e) {
            throw new Error(`Corrupted or invalid continuation token: ${decodedToken}`);
        }
    }
    extractOperationOptions(obj) {
        const { abortSignal, requestOptions, tracingOptions } = obj, restOptions = tslib.__rest(obj, ["abortSignal", "requestOptions", "tracingOptions"]);
        return {
            operationOptions: {
                abortSignal,
                requestOptions,
                tracingOptions
            },
            restOptions
        };
    }
    convertSelect(select) {
        if (select) {
            return select.join(",");
        }
        return select;
    }
    convertSearchFields(searchFields) {
        if (searchFields) {
            return searchFields.join(",");
        }
        return searchFields;
    }
    convertOrderBy(orderBy) {
        if (orderBy) {
            return orderBy.join(",");
        }
        return orderBy;
    }
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AnalyzeRequest = {
    serializedName: "AnalyzeRequest",
    type: {
        name: "Composite",
        className: "AnalyzeRequest",
        modelProperties: {
            text: {
                required: true,
                serializedName: "text",
                type: {
                    name: "String"
                }
            },
            analyzer: {
                serializedName: "analyzer",
                type: {
                    name: "String"
                }
            },
            tokenizer: {
                serializedName: "tokenizer",
                type: {
                    name: "String"
                }
            },
            tokenFilters: {
                serializedName: "tokenFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            charFilters: {
                serializedName: "charFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AnalyzedTokenInfo = {
    serializedName: "AnalyzedTokenInfo",
    type: {
        name: "Composite",
        className: "AnalyzedTokenInfo",
        modelProperties: {
            token: {
                required: true,
                readOnly: true,
                serializedName: "token",
                type: {
                    name: "String"
                }
            },
            startOffset: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "startOffset",
                type: {
                    name: "Number"
                }
            },
            endOffset: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "endOffset",
                type: {
                    name: "Number"
                }
            },
            position: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "position",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AnalyzeResult = {
    serializedName: "AnalyzeResult",
    type: {
        name: "Composite",
        className: "AnalyzeResult",
        modelProperties: {
            tokens: {
                required: true,
                serializedName: "tokens",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnalyzedTokenInfo"
                        }
                    }
                }
            }
        }
    }
};
const LexicalAnalyzer = {
    serializedName: "LexicalAnalyzer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: {
            serializedName: "@odata.type",
            clientName: "odatatype"
        },
        uberParent: "LexicalAnalyzer",
        className: "LexicalAnalyzer",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            odatatype: {
                required: true,
                serializedName: "@odata\\.type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.CustomAnalyzer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        uberParent: "LexicalAnalyzer",
        className: "CustomAnalyzer",
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { tokenizer: {
                required: true,
                serializedName: "tokenizer",
                type: {
                    name: "String"
                }
            }, tokenFilters: {
                serializedName: "tokenFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, charFilters: {
                serializedName: "charFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const PatternAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.PatternAnalyzer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        uberParent: "LexicalAnalyzer",
        className: "PatternAnalyzer",
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { lowerCaseTerms: {
                serializedName: "lowercase",
                defaultValue: true,
                type: {
                    name: "Boolean"
                }
            }, pattern: {
                serializedName: "pattern",
                defaultValue: '\W+',
                type: {
                    name: "String"
                }
            }, flags: {
                serializedName: "flags",
                type: {
                    name: "String"
                }
            }, stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const LuceneStandardAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.StandardAnalyzer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        uberParent: "LexicalAnalyzer",
        className: "LuceneStandardAnalyzer",
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { maxTokenLength: {
                serializedName: "maxTokenLength",
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StopAnalyzer = {
    serializedName: "#Microsoft.Azure.Search.StopAnalyzer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalAnalyzer.type.polymorphicDiscriminator,
        uberParent: "LexicalAnalyzer",
        className: "StopAnalyzer",
        modelProperties: Object.assign(Object.assign({}, LexicalAnalyzer.type.modelProperties), { stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const LexicalTokenizer = {
    serializedName: "LexicalTokenizer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: {
            serializedName: "@odata.type",
            clientName: "odatatype"
        },
        uberParent: "LexicalTokenizer",
        className: "LexicalTokenizer",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            odatatype: {
                required: true,
                serializedName: "@odata\\.type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClassicTokenizer = {
    serializedName: "#Microsoft.Azure.Search.ClassicTokenizer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "ClassicTokenizer",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                serializedName: "maxTokenLength",
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            } })
    }
};
const EdgeNGramTokenizer = {
    serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenizer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "EdgeNGramTokenizer",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { minGram: {
                serializedName: "minGram",
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, maxGram: {
                serializedName: "maxGram",
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, tokenChars: {
                serializedName: "tokenChars",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "letter",
                                "digit",
                                "whitespace",
                                "punctuation",
                                "symbol"
                            ]
                        }
                    }
                }
            } })
    }
};
const KeywordTokenizer = {
    serializedName: "#Microsoft.Azure.Search.KeywordTokenizer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "KeywordTokenizer",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { bufferSize: {
                serializedName: "bufferSize",
                defaultValue: 256,
                type: {
                    name: "Number"
                }
            } })
    }
};
const KeywordTokenizerV2 = {
    serializedName: "#Microsoft.Azure.Search.KeywordTokenizerV2",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "KeywordTokenizerV2",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                serializedName: "maxTokenLength",
                defaultValue: 256,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            } })
    }
};
const MicrosoftLanguageTokenizer = {
    serializedName: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "MicrosoftLanguageTokenizer",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                serializedName: "maxTokenLength",
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, isSearchTokenizer: {
                serializedName: "isSearchTokenizer",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            }, language: {
                serializedName: "language",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "bangla",
                        "bulgarian",
                        "catalan",
                        "chineseSimplified",
                        "chineseTraditional",
                        "croatian",
                        "czech",
                        "danish",
                        "dutch",
                        "english",
                        "french",
                        "german",
                        "greek",
                        "gujarati",
                        "hindi",
                        "icelandic",
                        "indonesian",
                        "italian",
                        "japanese",
                        "kannada",
                        "korean",
                        "malay",
                        "malayalam",
                        "marathi",
                        "norwegianBokmaal",
                        "polish",
                        "portuguese",
                        "portugueseBrazilian",
                        "punjabi",
                        "romanian",
                        "russian",
                        "serbianCyrillic",
                        "serbianLatin",
                        "slovenian",
                        "spanish",
                        "swedish",
                        "tamil",
                        "telugu",
                        "thai",
                        "ukrainian",
                        "urdu",
                        "vietnamese"
                    ]
                }
            } })
    }
};
const MicrosoftLanguageStemmingTokenizer = {
    serializedName: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "MicrosoftLanguageStemmingTokenizer",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                serializedName: "maxTokenLength",
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, isSearchTokenizer: {
                serializedName: "isSearchTokenizer",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            }, language: {
                serializedName: "language",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "arabic",
                        "bangla",
                        "bulgarian",
                        "catalan",
                        "croatian",
                        "czech",
                        "danish",
                        "dutch",
                        "english",
                        "estonian",
                        "finnish",
                        "french",
                        "german",
                        "greek",
                        "gujarati",
                        "hebrew",
                        "hindi",
                        "hungarian",
                        "icelandic",
                        "indonesian",
                        "italian",
                        "kannada",
                        "latvian",
                        "lithuanian",
                        "malay",
                        "malayalam",
                        "marathi",
                        "norwegianBokmaal",
                        "polish",
                        "portuguese",
                        "portugueseBrazilian",
                        "punjabi",
                        "romanian",
                        "russian",
                        "serbianCyrillic",
                        "serbianLatin",
                        "slovak",
                        "slovenian",
                        "spanish",
                        "swedish",
                        "tamil",
                        "telugu",
                        "turkish",
                        "ukrainian",
                        "urdu"
                    ]
                }
            } })
    }
};
const NGramTokenizer = {
    serializedName: "#Microsoft.Azure.Search.NGramTokenizer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "NGramTokenizer",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { minGram: {
                serializedName: "minGram",
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, maxGram: {
                serializedName: "maxGram",
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, tokenChars: {
                serializedName: "tokenChars",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "letter",
                                "digit",
                                "whitespace",
                                "punctuation",
                                "symbol"
                            ]
                        }
                    }
                }
            } })
    }
};
const PathHierarchyTokenizerV2 = {
    serializedName: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "PathHierarchyTokenizerV2",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { delimiter: {
                serializedName: "delimiter",
                defaultValue: '/',
                type: {
                    name: "String"
                }
            }, replacement: {
                serializedName: "replacement",
                defaultValue: '/',
                type: {
                    name: "String"
                }
            }, maxTokenLength: {
                serializedName: "maxTokenLength",
                defaultValue: 300,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, reverseTokenOrder: {
                serializedName: "reverse",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            }, numberOfTokensToSkip: {
                serializedName: "skip",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            } })
    }
};
const PatternTokenizer = {
    serializedName: "#Microsoft.Azure.Search.PatternTokenizer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "PatternTokenizer",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { pattern: {
                serializedName: "pattern",
                defaultValue: '\W+',
                type: {
                    name: "String"
                }
            }, flags: {
                serializedName: "flags",
                type: {
                    name: "String"
                }
            }, group: {
                serializedName: "group",
                defaultValue: -1,
                type: {
                    name: "Number"
                }
            } })
    }
};
const LuceneStandardTokenizer = {
    serializedName: "#Microsoft.Azure.Search.StandardTokenizer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "LuceneStandardTokenizer",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                serializedName: "maxTokenLength",
                defaultValue: 255,
                type: {
                    name: "Number"
                }
            } })
    }
};
const LuceneStandardTokenizerV2 = {
    serializedName: "#Microsoft.Azure.Search.StandardTokenizerV2",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "LuceneStandardTokenizerV2",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                serializedName: "maxTokenLength",
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            } })
    }
};
const UaxUrlEmailTokenizer = {
    serializedName: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer",
    type: {
        name: "Composite",
        polymorphicDiscriminator: LexicalTokenizer.type.polymorphicDiscriminator,
        uberParent: "LexicalTokenizer",
        className: "UaxUrlEmailTokenizer",
        modelProperties: Object.assign(Object.assign({}, LexicalTokenizer.type.modelProperties), { maxTokenLength: {
                serializedName: "maxTokenLength",
                defaultValue: 255,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            } })
    }
};
const TokenFilter = {
    serializedName: "TokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: {
            serializedName: "@odata.type",
            clientName: "odatatype"
        },
        uberParent: "TokenFilter",
        className: "TokenFilter",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            odatatype: {
                required: true,
                serializedName: "@odata\\.type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AsciiFoldingTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "AsciiFoldingTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { preserveOriginal: {
                serializedName: "preserveOriginal",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const CjkBigramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.CjkBigramTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "CjkBigramTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { ignoreScripts: {
                serializedName: "ignoreScripts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "han",
                                "hiragana",
                                "katakana",
                                "hangul"
                            ]
                        }
                    }
                }
            }, outputUnigrams: {
                serializedName: "outputUnigrams",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const CommonGramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.CommonGramTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "CommonGramTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { commonWords: {
                required: true,
                serializedName: "commonWords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, ignoreCase: {
                serializedName: "ignoreCase",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            }, useQueryMode: {
                serializedName: "queryMode",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DictionaryDecompounderTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "DictionaryDecompounderTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { wordList: {
                required: true,
                serializedName: "wordList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, minWordSize: {
                serializedName: "minWordSize",
                defaultValue: 5,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, minSubwordSize: {
                serializedName: "minSubwordSize",
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, maxSubwordSize: {
                serializedName: "maxSubwordSize",
                defaultValue: 15,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, onlyLongestMatch: {
                serializedName: "onlyLongestMatch",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const EdgeNGramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "EdgeNGramTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                serializedName: "minGram",
                defaultValue: 1,
                type: {
                    name: "Number"
                }
            }, maxGram: {
                serializedName: "maxGram",
                defaultValue: 2,
                type: {
                    name: "Number"
                }
            }, side: {
                serializedName: "side",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "front",
                        "back"
                    ]
                }
            } })
    }
};
const EdgeNGramTokenFilterV2 = {
    serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "EdgeNGramTokenFilterV2",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                serializedName: "minGram",
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, maxGram: {
                serializedName: "maxGram",
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, side: {
                serializedName: "side",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "front",
                        "back"
                    ]
                }
            } })
    }
};
const ElisionTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.ElisionTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "ElisionTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { articles: {
                serializedName: "articles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const KeepTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.KeepTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "KeepTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { keepWords: {
                required: true,
                serializedName: "keepWords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, lowerCaseKeepWords: {
                serializedName: "keepWordsCase",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const KeywordMarkerTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "KeywordMarkerTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { keywords: {
                required: true,
                serializedName: "keywords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, ignoreCase: {
                serializedName: "ignoreCase",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const LengthTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.LengthTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "LengthTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minLength: {
                serializedName: "min",
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, maxLength: {
                serializedName: "max",
                defaultValue: 300,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            } })
    }
};
const LimitTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.LimitTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "LimitTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { maxTokenCount: {
                serializedName: "maxTokenCount",
                defaultValue: 1,
                type: {
                    name: "Number"
                }
            }, consumeAllTokens: {
                serializedName: "consumeAllTokens",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const NGramTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.NGramTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "NGramTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                serializedName: "minGram",
                defaultValue: 1,
                type: {
                    name: "Number"
                }
            }, maxGram: {
                serializedName: "maxGram",
                defaultValue: 2,
                type: {
                    name: "Number"
                }
            } })
    }
};
const NGramTokenFilterV2 = {
    serializedName: "#Microsoft.Azure.Search.NGramTokenFilterV2",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "NGramTokenFilterV2",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { minGram: {
                serializedName: "minGram",
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            }, maxGram: {
                serializedName: "maxGram",
                defaultValue: 2,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            } })
    }
};
const PatternCaptureTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.PatternCaptureTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "PatternCaptureTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { patterns: {
                required: true,
                serializedName: "patterns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, preserveOriginal: {
                serializedName: "preserveOriginal",
                defaultValue: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const PatternReplaceTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.PatternReplaceTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "PatternReplaceTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { pattern: {
                required: true,
                serializedName: "pattern",
                type: {
                    name: "String"
                }
            }, replacement: {
                required: true,
                serializedName: "replacement",
                type: {
                    name: "String"
                }
            } })
    }
};
const PhoneticTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.PhoneticTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "PhoneticTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { encoder: {
                serializedName: "encoder",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "metaphone",
                        "doubleMetaphone",
                        "soundex",
                        "refinedSoundex",
                        "caverphone1",
                        "caverphone2",
                        "cologne",
                        "nysiis",
                        "koelnerPhonetik",
                        "haasePhonetik",
                        "beiderMorse"
                    ]
                }
            }, replaceOriginalTokens: {
                serializedName: "replace",
                defaultValue: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ShingleTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.ShingleTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "ShingleTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { maxShingleSize: {
                serializedName: "maxShingleSize",
                defaultValue: 2,
                constraints: {
                    InclusiveMinimum: 2
                },
                type: {
                    name: "Number"
                }
            }, minShingleSize: {
                serializedName: "minShingleSize",
                defaultValue: 2,
                constraints: {
                    InclusiveMinimum: 2
                },
                type: {
                    name: "Number"
                }
            }, outputUnigrams: {
                serializedName: "outputUnigrams",
                defaultValue: true,
                type: {
                    name: "Boolean"
                }
            }, outputUnigramsIfNoShingles: {
                serializedName: "outputUnigramsIfNoShingles",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            }, tokenSeparator: {
                serializedName: "tokenSeparator",
                defaultValue: '',
                type: {
                    name: "String"
                }
            }, filterToken: {
                serializedName: "filterToken",
                defaultValue: '_',
                type: {
                    name: "String"
                }
            } })
    }
};
const SnowballTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.SnowballTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "SnowballTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { language: {
                required: true,
                serializedName: "language",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "armenian",
                        "basque",
                        "catalan",
                        "danish",
                        "dutch",
                        "english",
                        "finnish",
                        "french",
                        "german",
                        "german2",
                        "hungarian",
                        "italian",
                        "kp",
                        "lovins",
                        "norwegian",
                        "porter",
                        "portuguese",
                        "romanian",
                        "russian",
                        "spanish",
                        "swedish",
                        "turkish"
                    ]
                }
            } })
    }
};
const StemmerTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.StemmerTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "StemmerTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { language: {
                required: true,
                serializedName: "language",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "arabic",
                        "armenian",
                        "basque",
                        "brazilian",
                        "bulgarian",
                        "catalan",
                        "czech",
                        "danish",
                        "dutch",
                        "dutchKp",
                        "english",
                        "lightEnglish",
                        "minimalEnglish",
                        "possessiveEnglish",
                        "porter2",
                        "lovins",
                        "finnish",
                        "lightFinnish",
                        "french",
                        "lightFrench",
                        "minimalFrench",
                        "galician",
                        "minimalGalician",
                        "german",
                        "german2",
                        "lightGerman",
                        "minimalGerman",
                        "greek",
                        "hindi",
                        "hungarian",
                        "lightHungarian",
                        "indonesian",
                        "irish",
                        "italian",
                        "lightItalian",
                        "sorani",
                        "latvian",
                        "norwegian",
                        "lightNorwegian",
                        "minimalNorwegian",
                        "lightNynorsk",
                        "minimalNynorsk",
                        "portuguese",
                        "lightPortuguese",
                        "minimalPortuguese",
                        "portugueseRslp",
                        "romanian",
                        "russian",
                        "lightRussian",
                        "spanish",
                        "lightSpanish",
                        "swedish",
                        "lightSwedish",
                        "turkish"
                    ]
                }
            } })
    }
};
const StemmerOverrideTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "StemmerOverrideTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { rules: {
                required: true,
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StopwordsTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.StopwordsTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "StopwordsTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { stopwords: {
                serializedName: "stopwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, stopwordsList: {
                serializedName: "stopwordsList",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "arabic",
                        "armenian",
                        "basque",
                        "brazilian",
                        "bulgarian",
                        "catalan",
                        "czech",
                        "danish",
                        "dutch",
                        "english",
                        "finnish",
                        "french",
                        "galician",
                        "german",
                        "greek",
                        "hindi",
                        "hungarian",
                        "indonesian",
                        "irish",
                        "italian",
                        "latvian",
                        "norwegian",
                        "persian",
                        "portuguese",
                        "romanian",
                        "russian",
                        "sorani",
                        "spanish",
                        "swedish",
                        "thai",
                        "turkish"
                    ]
                }
            }, ignoreCase: {
                serializedName: "ignoreCase",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            }, removeTrailingStopWords: {
                serializedName: "removeTrailing",
                defaultValue: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const SynonymTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.SynonymTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "SynonymTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { synonyms: {
                required: true,
                serializedName: "synonyms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, ignoreCase: {
                serializedName: "ignoreCase",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            }, expand: {
                serializedName: "expand",
                defaultValue: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const TruncateTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.TruncateTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "TruncateTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { length: {
                serializedName: "length",
                defaultValue: 300,
                constraints: {
                    InclusiveMaximum: 300
                },
                type: {
                    name: "Number"
                }
            } })
    }
};
const UniqueTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.UniqueTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "UniqueTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { onlyOnSamePosition: {
                serializedName: "onlyOnSamePosition",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const WordDelimiterTokenFilter = {
    serializedName: "#Microsoft.Azure.Search.WordDelimiterTokenFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
        uberParent: "TokenFilter",
        className: "WordDelimiterTokenFilter",
        modelProperties: Object.assign(Object.assign({}, TokenFilter.type.modelProperties), { generateWordParts: {
                serializedName: "generateWordParts",
                defaultValue: true,
                type: {
                    name: "Boolean"
                }
            }, generateNumberParts: {
                serializedName: "generateNumberParts",
                defaultValue: true,
                type: {
                    name: "Boolean"
                }
            }, catenateWords: {
                serializedName: "catenateWords",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            }, catenateNumbers: {
                serializedName: "catenateNumbers",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            }, catenateAll: {
                serializedName: "catenateAll",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            }, splitOnCaseChange: {
                serializedName: "splitOnCaseChange",
                defaultValue: true,
                type: {
                    name: "Boolean"
                }
            }, preserveOriginal: {
                serializedName: "preserveOriginal",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            }, splitOnNumerics: {
                serializedName: "splitOnNumerics",
                defaultValue: true,
                type: {
                    name: "Boolean"
                }
            }, stemEnglishPossessive: {
                serializedName: "stemEnglishPossessive",
                defaultValue: true,
                type: {
                    name: "Boolean"
                }
            }, protectedWords: {
                serializedName: "protectedWords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const CharFilter = {
    serializedName: "CharFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: {
            serializedName: "@odata.type",
            clientName: "odatatype"
        },
        uberParent: "CharFilter",
        className: "CharFilter",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            odatatype: {
                required: true,
                serializedName: "@odata\\.type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MappingCharFilter = {
    serializedName: "#Microsoft.Azure.Search.MappingCharFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: CharFilter.type.polymorphicDiscriminator,
        uberParent: "CharFilter",
        className: "MappingCharFilter",
        modelProperties: Object.assign(Object.assign({}, CharFilter.type.modelProperties), { mappings: {
                required: true,
                serializedName: "mappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const PatternReplaceCharFilter = {
    serializedName: "#Microsoft.Azure.Search.PatternReplaceCharFilter",
    type: {
        name: "Composite",
        polymorphicDiscriminator: CharFilter.type.polymorphicDiscriminator,
        uberParent: "CharFilter",
        className: "PatternReplaceCharFilter",
        modelProperties: Object.assign(Object.assign({}, CharFilter.type.modelProperties), { pattern: {
                required: true,
                serializedName: "pattern",
                type: {
                    name: "String"
                }
            }, replacement: {
                required: true,
                serializedName: "replacement",
                type: {
                    name: "String"
                }
            } })
    }
};
const Similarity = {
    serializedName: "Similarity",
    type: {
        name: "Composite",
        polymorphicDiscriminator: {
            serializedName: "@odata.type",
            clientName: "odatatype"
        },
        uberParent: "Similarity",
        className: "Similarity",
        modelProperties: {
            odatatype: {
                required: true,
                serializedName: "@odata\\.type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClassicSimilarity = {
    serializedName: "#Microsoft.Azure.Search.ClassicSimilarity",
    type: {
        name: "Composite",
        polymorphicDiscriminator: Similarity.type.polymorphicDiscriminator,
        uberParent: "Similarity",
        className: "ClassicSimilarity",
        modelProperties: Object.assign({}, Similarity.type.modelProperties)
    }
};
const BM25Similarity = {
    serializedName: "#Microsoft.Azure.Search.BM25Similarity",
    type: {
        name: "Composite",
        polymorphicDiscriminator: Similarity.type.polymorphicDiscriminator,
        uberParent: "Similarity",
        className: "BM25Similarity",
        modelProperties: Object.assign(Object.assign({}, Similarity.type.modelProperties), { k1: {
                serializedName: "k1",
                type: {
                    name: "Number"
                }
            }, b: {
                serializedName: "b",
                type: {
                    name: "Number"
                }
            } })
    }
};
const DataSourceCredentials = {
    serializedName: "DataSourceCredentials",
    type: {
        name: "Composite",
        className: "DataSourceCredentials",
        modelProperties: {
            connectionString: {
                serializedName: "connectionString",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerDataContainer = {
    serializedName: "SearchIndexerDataContainer",
    type: {
        name: "Composite",
        className: "SearchIndexerDataContainer",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            query: {
                serializedName: "query",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataChangeDetectionPolicy = {
    serializedName: "DataChangeDetectionPolicy",
    type: {
        name: "Composite",
        polymorphicDiscriminator: {
            serializedName: "@odata.type",
            clientName: "odatatype"
        },
        uberParent: "DataChangeDetectionPolicy",
        className: "DataChangeDetectionPolicy",
        modelProperties: {
            odatatype: {
                required: true,
                serializedName: "@odata\\.type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HighWaterMarkChangeDetectionPolicy = {
    serializedName: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
    type: {
        name: "Composite",
        polymorphicDiscriminator: DataChangeDetectionPolicy.type.polymorphicDiscriminator,
        uberParent: "DataChangeDetectionPolicy",
        className: "HighWaterMarkChangeDetectionPolicy",
        modelProperties: Object.assign(Object.assign({}, DataChangeDetectionPolicy.type.modelProperties), { highWaterMarkColumnName: {
                required: true,
                serializedName: "highWaterMarkColumnName",
                type: {
                    name: "String"
                }
            } })
    }
};
const SqlIntegratedChangeTrackingPolicy = {
    serializedName: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy",
    type: {
        name: "Composite",
        polymorphicDiscriminator: DataChangeDetectionPolicy.type.polymorphicDiscriminator,
        uberParent: "DataChangeDetectionPolicy",
        className: "SqlIntegratedChangeTrackingPolicy",
        modelProperties: Object.assign({}, DataChangeDetectionPolicy.type.modelProperties)
    }
};
const DataDeletionDetectionPolicy = {
    serializedName: "DataDeletionDetectionPolicy",
    type: {
        name: "Composite",
        polymorphicDiscriminator: {
            serializedName: "@odata.type",
            clientName: "odatatype"
        },
        uberParent: "DataDeletionDetectionPolicy",
        className: "DataDeletionDetectionPolicy",
        modelProperties: {
            odatatype: {
                required: true,
                serializedName: "@odata\\.type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SoftDeleteColumnDeletionDetectionPolicy = {
    serializedName: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
    type: {
        name: "Composite",
        polymorphicDiscriminator: DataDeletionDetectionPolicy.type.polymorphicDiscriminator,
        uberParent: "DataDeletionDetectionPolicy",
        className: "SoftDeleteColumnDeletionDetectionPolicy",
        modelProperties: Object.assign(Object.assign({}, DataDeletionDetectionPolicy.type.modelProperties), { softDeleteColumnName: {
                serializedName: "softDeleteColumnName",
                type: {
                    name: "String"
                }
            }, softDeleteMarkerValue: {
                serializedName: "softDeleteMarkerValue",
                type: {
                    name: "String"
                }
            } })
    }
};
const SearchIndexerDataSource = {
    serializedName: "SearchIndexerDataSource",
    type: {
        name: "Composite",
        className: "SearchIndexerDataSource",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            type: {
                required: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            credentials: {
                required: true,
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "DataSourceCredentials"
                }
            },
            container: {
                required: true,
                serializedName: "container",
                type: {
                    name: "Composite",
                    className: "SearchIndexerDataContainer"
                }
            },
            dataChangeDetectionPolicy: {
                serializedName: "dataChangeDetectionPolicy",
                type: {
                    name: "Composite",
                    className: "DataChangeDetectionPolicy"
                }
            },
            dataDeletionDetectionPolicy: {
                serializedName: "dataDeletionDetectionPolicy",
                type: {
                    name: "Composite",
                    className: "DataDeletionDetectionPolicy"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListDataSourcesResult = {
    serializedName: "ListDataSourcesResult",
    type: {
        name: "Composite",
        className: "ListDataSourcesResult",
        modelProperties: {
            dataSources: {
                required: true,
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerDataSource"
                        }
                    }
                }
            }
        }
    }
};
const IndexingSchedule = {
    serializedName: "IndexingSchedule",
    type: {
        name: "Composite",
        className: "IndexingSchedule",
        modelProperties: {
            interval: {
                required: true,
                serializedName: "interval",
                type: {
                    name: "TimeSpan"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const IndexingParameters = {
    serializedName: "IndexingParameters",
    type: {
        name: "Composite",
        className: "IndexingParameters",
        modelProperties: {
            batchSize: {
                serializedName: "batchSize",
                type: {
                    name: "Number"
                }
            },
            maxFailedItems: {
                serializedName: "maxFailedItems",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            },
            maxFailedItemsPerBatch: {
                serializedName: "maxFailedItemsPerBatch",
                defaultValue: 0,
                type: {
                    name: "Number"
                }
            },
            configuration: {
                serializedName: "configuration",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Object"
                        }
                    }
                }
            }
        }
    }
};
const FieldMappingFunction = {
    serializedName: "FieldMappingFunction",
    type: {
        name: "Composite",
        className: "FieldMappingFunction",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Object"
                        }
                    }
                }
            }
        }
    }
};
const FieldMapping = {
    serializedName: "FieldMapping",
    type: {
        name: "Composite",
        className: "FieldMapping",
        modelProperties: {
            sourceFieldName: {
                required: true,
                serializedName: "sourceFieldName",
                type: {
                    name: "String"
                }
            },
            targetFieldName: {
                serializedName: "targetFieldName",
                type: {
                    name: "String"
                }
            },
            mappingFunction: {
                serializedName: "mappingFunction",
                type: {
                    name: "Composite",
                    className: "FieldMappingFunction"
                }
            }
        }
    }
};
const SearchIndexer = {
    serializedName: "SearchIndexer",
    type: {
        name: "Composite",
        className: "SearchIndexer",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            dataSourceName: {
                required: true,
                serializedName: "dataSourceName",
                type: {
                    name: "String"
                }
            },
            skillsetName: {
                serializedName: "skillsetName",
                type: {
                    name: "String"
                }
            },
            targetIndexName: {
                required: true,
                serializedName: "targetIndexName",
                type: {
                    name: "String"
                }
            },
            schedule: {
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "IndexingSchedule"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "IndexingParameters"
                }
            },
            fieldMappings: {
                serializedName: "fieldMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FieldMapping"
                        }
                    }
                }
            },
            outputFieldMappings: {
                serializedName: "outputFieldMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FieldMapping"
                        }
                    }
                }
            },
            isDisabled: {
                serializedName: "disabled",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListIndexersResult = {
    serializedName: "ListIndexersResult",
    type: {
        name: "Composite",
        className: "ListIndexersResult",
        modelProperties: {
            indexers: {
                required: true,
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexer"
                        }
                    }
                }
            }
        }
    }
};
const SearchIndexerError = {
    serializedName: "SearchIndexerError",
    type: {
        name: "Composite",
        className: "SearchIndexerError",
        modelProperties: {
            key: {
                readOnly: true,
                serializedName: "key",
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                required: true,
                readOnly: true,
                serializedName: "errorMessage",
                type: {
                    name: "String"
                }
            },
            statusCode: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "statusCode",
                type: {
                    name: "Number"
                }
            },
            name: {
                readOnly: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            details: {
                readOnly: true,
                serializedName: "details",
                type: {
                    name: "String"
                }
            },
            documentationLink: {
                readOnly: true,
                serializedName: "documentationLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerWarning = {
    serializedName: "SearchIndexerWarning",
    type: {
        name: "Composite",
        className: "SearchIndexerWarning",
        modelProperties: {
            key: {
                readOnly: true,
                serializedName: "key",
                type: {
                    name: "String"
                }
            },
            message: {
                required: true,
                readOnly: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            name: {
                readOnly: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            details: {
                readOnly: true,
                serializedName: "details",
                type: {
                    name: "String"
                }
            },
            documentationLink: {
                readOnly: true,
                serializedName: "documentationLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IndexerExecutionResult = {
    serializedName: "IndexerExecutionResult",
    type: {
        name: "Composite",
        className: "IndexerExecutionResult",
        modelProperties: {
            status: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "transientFailure",
                        "success",
                        "inProgress",
                        "reset"
                    ]
                }
            },
            errorMessage: {
                readOnly: true,
                serializedName: "errorMessage",
                type: {
                    name: "String"
                }
            },
            startTime: {
                readOnly: true,
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                readOnly: true,
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            errors: {
                required: true,
                readOnly: true,
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerError"
                        }
                    }
                }
            },
            warnings: {
                required: true,
                readOnly: true,
                serializedName: "warnings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerWarning"
                        }
                    }
                }
            },
            itemCount: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "itemsProcessed",
                type: {
                    name: "Number"
                }
            },
            failedItemCount: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "itemsFailed",
                type: {
                    name: "Number"
                }
            },
            initialTrackingState: {
                readOnly: true,
                serializedName: "initialTrackingState",
                type: {
                    name: "String"
                }
            },
            finalTrackingState: {
                readOnly: true,
                serializedName: "finalTrackingState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerLimits = {
    serializedName: "SearchIndexerLimits",
    type: {
        name: "Composite",
        className: "SearchIndexerLimits",
        modelProperties: {
            maxRunTime: {
                readOnly: true,
                serializedName: "maxRunTime",
                type: {
                    name: "TimeSpan"
                }
            },
            maxDocumentExtractionSize: {
                readOnly: true,
                serializedName: "maxDocumentExtractionSize",
                type: {
                    name: "Number"
                }
            },
            maxDocumentContentCharactersToExtract: {
                readOnly: true,
                serializedName: "maxDocumentContentCharactersToExtract",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SearchIndexerStatus = {
    serializedName: "SearchIndexerStatus",
    type: {
        name: "Composite",
        className: "SearchIndexerStatus",
        modelProperties: {
            status: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "status",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "unknown",
                        "error",
                        "running"
                    ]
                }
            },
            lastResult: {
                readOnly: true,
                serializedName: "lastResult",
                type: {
                    name: "Composite",
                    className: "IndexerExecutionResult"
                }
            },
            executionHistory: {
                required: true,
                readOnly: true,
                serializedName: "executionHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IndexerExecutionResult"
                        }
                    }
                }
            },
            limits: {
                required: true,
                readOnly: true,
                serializedName: "limits",
                type: {
                    name: "Composite",
                    className: "SearchIndexerLimits"
                }
            }
        }
    }
};
const SearchField = {
    serializedName: "SearchField",
    type: {
        name: "Composite",
        className: "SearchField",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                required: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                type: {
                    name: "Boolean"
                }
            },
            retrievable: {
                serializedName: "retrievable",
                type: {
                    name: "Boolean"
                }
            },
            searchable: {
                serializedName: "searchable",
                type: {
                    name: "Boolean"
                }
            },
            filterable: {
                serializedName: "filterable",
                type: {
                    name: "Boolean"
                }
            },
            sortable: {
                serializedName: "sortable",
                type: {
                    name: "Boolean"
                }
            },
            facetable: {
                serializedName: "facetable",
                type: {
                    name: "Boolean"
                }
            },
            analyzer: {
                serializedName: "analyzer",
                type: {
                    name: "String"
                }
            },
            searchAnalyzer: {
                serializedName: "searchAnalyzer",
                type: {
                    name: "String"
                }
            },
            indexAnalyzer: {
                serializedName: "indexAnalyzer",
                type: {
                    name: "String"
                }
            },
            synonymMaps: {
                serializedName: "synonymMaps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            fields: {
                serializedName: "fields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchField"
                        }
                    }
                }
            }
        }
    }
};
const TextWeights = {
    serializedName: "TextWeights",
    type: {
        name: "Composite",
        className: "TextWeights",
        modelProperties: {
            weights: {
                required: true,
                serializedName: "weights",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const ScoringFunction = {
    serializedName: "ScoringFunction",
    type: {
        name: "Composite",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        uberParent: "ScoringFunction",
        className: "ScoringFunction",
        modelProperties: {
            fieldName: {
                required: true,
                serializedName: "fieldName",
                type: {
                    name: "String"
                }
            },
            boost: {
                required: true,
                serializedName: "boost",
                type: {
                    name: "Number"
                }
            },
            interpolation: {
                serializedName: "interpolation",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "linear",
                        "constant",
                        "quadratic",
                        "logarithmic"
                    ]
                }
            },
            type: {
                required: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DistanceScoringParameters = {
    serializedName: "DistanceScoringParameters",
    type: {
        name: "Composite",
        className: "DistanceScoringParameters",
        modelProperties: {
            referencePointParameter: {
                required: true,
                serializedName: "referencePointParameter",
                type: {
                    name: "String"
                }
            },
            boostingDistance: {
                required: true,
                serializedName: "boostingDistance",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DistanceScoringFunction = {
    serializedName: "distance",
    type: {
        name: "Composite",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        uberParent: "ScoringFunction",
        className: "DistanceScoringFunction",
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                required: true,
                serializedName: "distance",
                type: {
                    name: "Composite",
                    className: "DistanceScoringParameters"
                }
            } })
    }
};
const FreshnessScoringParameters = {
    serializedName: "FreshnessScoringParameters",
    type: {
        name: "Composite",
        className: "FreshnessScoringParameters",
        modelProperties: {
            boostingDuration: {
                required: true,
                serializedName: "boostingDuration",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const FreshnessScoringFunction = {
    serializedName: "freshness",
    type: {
        name: "Composite",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        uberParent: "ScoringFunction",
        className: "FreshnessScoringFunction",
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                required: true,
                serializedName: "freshness",
                type: {
                    name: "Composite",
                    className: "FreshnessScoringParameters"
                }
            } })
    }
};
const MagnitudeScoringParameters = {
    serializedName: "MagnitudeScoringParameters",
    type: {
        name: "Composite",
        className: "MagnitudeScoringParameters",
        modelProperties: {
            boostingRangeStart: {
                required: true,
                serializedName: "boostingRangeStart",
                type: {
                    name: "Number"
                }
            },
            boostingRangeEnd: {
                required: true,
                serializedName: "boostingRangeEnd",
                type: {
                    name: "Number"
                }
            },
            shouldBoostBeyondRangeByConstant: {
                serializedName: "constantBoostBeyondRange",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const MagnitudeScoringFunction = {
    serializedName: "magnitude",
    type: {
        name: "Composite",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        uberParent: "ScoringFunction",
        className: "MagnitudeScoringFunction",
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                required: true,
                serializedName: "magnitude",
                type: {
                    name: "Composite",
                    className: "MagnitudeScoringParameters"
                }
            } })
    }
};
const TagScoringParameters = {
    serializedName: "TagScoringParameters",
    type: {
        name: "Composite",
        className: "TagScoringParameters",
        modelProperties: {
            tagsParameter: {
                required: true,
                serializedName: "tagsParameter",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagScoringFunction = {
    serializedName: "tag",
    type: {
        name: "Composite",
        polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
        uberParent: "ScoringFunction",
        className: "TagScoringFunction",
        modelProperties: Object.assign(Object.assign({}, ScoringFunction.type.modelProperties), { parameters: {
                required: true,
                serializedName: "tag",
                type: {
                    name: "Composite",
                    className: "TagScoringParameters"
                }
            } })
    }
};
const ScoringProfile = {
    serializedName: "ScoringProfile",
    type: {
        name: "Composite",
        className: "ScoringProfile",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            textWeights: {
                serializedName: "text",
                type: {
                    name: "Composite",
                    className: "TextWeights"
                }
            },
            functions: {
                serializedName: "functions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScoringFunction"
                        }
                    }
                }
            },
            functionAggregation: {
                serializedName: "functionAggregation",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "sum",
                        "average",
                        "minimum",
                        "maximum",
                        "firstMatching"
                    ]
                }
            }
        }
    }
};
const CorsOptions = {
    serializedName: "CorsOptions",
    type: {
        name: "Composite",
        className: "CorsOptions",
        modelProperties: {
            allowedOrigins: {
                required: true,
                serializedName: "allowedOrigins",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            maxAgeInSeconds: {
                serializedName: "maxAgeInSeconds",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Suggester = {
    serializedName: "Suggester",
    type: {
        name: "Composite",
        className: "Suggester",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            searchMode: {
                required: true,
                isConstant: true,
                serializedName: "searchMode",
                defaultValue: 'analyzingInfixMatching',
                type: {
                    name: "String"
                }
            },
            sourceFields: {
                required: true,
                serializedName: "sourceFields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AzureActiveDirectoryApplicationCredentials = {
    serializedName: "AzureActiveDirectoryApplicationCredentials",
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryApplicationCredentials",
        modelProperties: {
            applicationId: {
                required: true,
                serializedName: "applicationId",
                type: {
                    name: "String"
                }
            },
            applicationSecret: {
                serializedName: "applicationSecret",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchResourceEncryptionKey = {
    serializedName: "SearchResourceEncryptionKey",
    type: {
        name: "Composite",
        className: "SearchResourceEncryptionKey",
        modelProperties: {
            keyName: {
                required: true,
                serializedName: "keyVaultKeyName",
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                required: true,
                serializedName: "keyVaultKeyVersion",
                type: {
                    name: "String"
                }
            },
            vaultUri: {
                required: true,
                serializedName: "keyVaultUri",
                type: {
                    name: "String"
                }
            },
            accessCredentials: {
                serializedName: "accessCredentials",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryApplicationCredentials"
                }
            }
        }
    }
};
const SearchIndex = {
    serializedName: "SearchIndex",
    type: {
        name: "Composite",
        className: "SearchIndex",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            fields: {
                required: true,
                serializedName: "fields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchField"
                        }
                    }
                }
            },
            scoringProfiles: {
                serializedName: "scoringProfiles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScoringProfile"
                        }
                    }
                }
            },
            defaultScoringProfile: {
                serializedName: "defaultScoringProfile",
                type: {
                    name: "String"
                }
            },
            corsOptions: {
                serializedName: "corsOptions",
                type: {
                    name: "Composite",
                    className: "CorsOptions"
                }
            },
            suggesters: {
                serializedName: "suggesters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Suggester"
                        }
                    }
                }
            },
            analyzers: {
                serializedName: "analyzers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LexicalAnalyzer"
                        }
                    }
                }
            },
            tokenizers: {
                serializedName: "tokenizers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LexicalTokenizer"
                        }
                    }
                }
            },
            tokenFilters: {
                serializedName: "tokenFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TokenFilter"
                        }
                    }
                }
            },
            charFilters: {
                serializedName: "charFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CharFilter"
                        }
                    }
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            },
            similarity: {
                serializedName: "similarity",
                type: {
                    name: "Composite",
                    className: "Similarity"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetIndexStatisticsResult = {
    serializedName: "GetIndexStatisticsResult",
    type: {
        name: "Composite",
        className: "GetIndexStatisticsResult",
        modelProperties: {
            documentCount: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "documentCount",
                type: {
                    name: "Number"
                }
            },
            storageSize: {
                required: true,
                nullable: false,
                readOnly: true,
                serializedName: "storageSize",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ListIndexesResult = {
    serializedName: "ListIndexesResult",
    type: {
        name: "Composite",
        className: "ListIndexesResult",
        modelProperties: {
            indexes: {
                required: true,
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndex"
                        }
                    }
                }
            }
        }
    }
};
const InputFieldMappingEntry = {
    serializedName: "InputFieldMappingEntry",
    type: {
        name: "Composite",
        className: "InputFieldMappingEntry",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "String"
                }
            },
            sourceContext: {
                serializedName: "sourceContext",
                type: {
                    name: "String"
                }
            },
            inputs: {
                serializedName: "inputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InputFieldMappingEntry"
                        }
                    }
                }
            }
        }
    }
};
const OutputFieldMappingEntry = {
    serializedName: "OutputFieldMappingEntry",
    type: {
        name: "Composite",
        className: "OutputFieldMappingEntry",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            targetName: {
                serializedName: "targetName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerSkill = {
    serializedName: "SearchIndexerSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: {
            serializedName: "@odata.type",
            clientName: "odatatype"
        },
        uberParent: "SearchIndexerSkill",
        className: "SearchIndexerSkill",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            context: {
                serializedName: "context",
                type: {
                    name: "String"
                }
            },
            inputs: {
                required: true,
                serializedName: "inputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InputFieldMappingEntry"
                        }
                    }
                }
            },
            outputs: {
                required: true,
                serializedName: "outputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutputFieldMappingEntry"
                        }
                    }
                }
            },
            odatatype: {
                required: true,
                serializedName: "@odata\\.type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CognitiveServicesAccount = {
    serializedName: "CognitiveServicesAccount",
    type: {
        name: "Composite",
        polymorphicDiscriminator: {
            serializedName: "@odata.type",
            clientName: "odatatype"
        },
        uberParent: "CognitiveServicesAccount",
        className: "CognitiveServicesAccount",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            odatatype: {
                required: true,
                serializedName: "@odata\\.type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SearchIndexerSkillset = {
    serializedName: "SearchIndexerSkillset",
    type: {
        name: "Composite",
        className: "SearchIndexerSkillset",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            skills: {
                required: true,
                serializedName: "skills",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerSkill"
                        }
                    }
                }
            },
            cognitiveServicesAccount: {
                serializedName: "cognitiveServices",
                type: {
                    name: "Composite",
                    className: "CognitiveServicesAccount"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DefaultCognitiveServicesAccount = {
    serializedName: "#Microsoft.Azure.Search.DefaultCognitiveServices",
    type: {
        name: "Composite",
        polymorphicDiscriminator: CognitiveServicesAccount.type.polymorphicDiscriminator,
        uberParent: "CognitiveServicesAccount",
        className: "DefaultCognitiveServicesAccount",
        modelProperties: Object.assign({}, CognitiveServicesAccount.type.modelProperties)
    }
};
const CognitiveServicesAccountKey = {
    serializedName: "#Microsoft.Azure.Search.CognitiveServicesByKey",
    type: {
        name: "Composite",
        polymorphicDiscriminator: CognitiveServicesAccount.type.polymorphicDiscriminator,
        uberParent: "CognitiveServicesAccount",
        className: "CognitiveServicesAccountKey",
        modelProperties: Object.assign(Object.assign({}, CognitiveServicesAccount.type.modelProperties), { key: {
                required: true,
                serializedName: "key",
                type: {
                    name: "String"
                }
            } })
    }
};
const ConditionalSkill = {
    serializedName: "#Microsoft.Skills.Util.ConditionalSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "ConditionalSkill",
        modelProperties: Object.assign({}, SearchIndexerSkill.type.modelProperties)
    }
};
const KeyPhraseExtractionSkill = {
    serializedName: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "KeyPhraseExtractionSkill",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, maxKeyPhraseCount: {
                nullable: true,
                serializedName: "maxKeyPhraseCount",
                type: {
                    name: "Number"
                }
            } })
    }
};
const OcrSkill = {
    serializedName: "#Microsoft.Skills.Vision.OcrSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "OcrSkill",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, shouldDetectOrientation: {
                serializedName: "detectOrientation",
                defaultValue: false,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ImageAnalysisSkill = {
    serializedName: "#Microsoft.Skills.Vision.ImageAnalysisSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "ImageAnalysisSkill",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, visualFeatures: {
                serializedName: "visualFeatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const LanguageDetectionSkill = {
    serializedName: "#Microsoft.Skills.Text.LanguageDetectionSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "LanguageDetectionSkill",
        modelProperties: Object.assign({}, SearchIndexerSkill.type.modelProperties)
    }
};
const ShaperSkill = {
    serializedName: "#Microsoft.Skills.Util.ShaperSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "ShaperSkill",
        modelProperties: Object.assign({}, SearchIndexerSkill.type.modelProperties)
    }
};
const MergeSkill = {
    serializedName: "#Microsoft.Skills.Text.MergeSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "MergeSkill",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { insertPreTag: {
                serializedName: "insertPreTag",
                defaultValue: '',
                type: {
                    name: "String"
                }
            }, insertPostTag: {
                serializedName: "insertPostTag",
                defaultValue: '',
                type: {
                    name: "String"
                }
            } })
    }
};
const EntityRecognitionSkill = {
    serializedName: "#Microsoft.Skills.Text.EntityRecognitionSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "EntityRecognitionSkill",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, includeTypelessEntities: {
                nullable: true,
                serializedName: "includeTypelessEntities",
                type: {
                    name: "Boolean"
                }
            }, minimumPrecision: {
                nullable: true,
                serializedName: "minimumPrecision",
                type: {
                    name: "Number"
                }
            } })
    }
};
const SentimentSkill = {
    serializedName: "#Microsoft.Skills.Text.SentimentSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "SentimentSkill",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            } })
    }
};
const SplitSkill = {
    serializedName: "#Microsoft.Skills.Text.SplitSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "SplitSkill",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultLanguageCode: {
                serializedName: "defaultLanguageCode",
                type: {
                    name: "String"
                }
            }, textSplitMode: {
                serializedName: "textSplitMode",
                type: {
                    name: "String"
                }
            }, maxPageLength: {
                nullable: true,
                serializedName: "maximumPageLength",
                type: {
                    name: "Number"
                }
            } })
    }
};
const TextTranslationSkill = {
    serializedName: "#Microsoft.Skills.Text.TranslationSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "TextTranslationSkill",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { defaultToLanguageCode: {
                required: true,
                serializedName: "defaultToLanguageCode",
                type: {
                    name: "String"
                }
            }, defaultFromLanguageCode: {
                serializedName: "defaultFromLanguageCode",
                type: {
                    name: "String"
                }
            }, suggestedFrom: {
                serializedName: "suggestedFrom",
                type: {
                    name: "String"
                }
            } })
    }
};
const WebApiSkill = {
    serializedName: "#Microsoft.Skills.Custom.WebApiSkill",
    type: {
        name: "Composite",
        polymorphicDiscriminator: SearchIndexerSkill.type.polymorphicDiscriminator,
        uberParent: "SearchIndexerSkill",
        className: "WebApiSkill",
        modelProperties: Object.assign(Object.assign({}, SearchIndexerSkill.type.modelProperties), { uri: {
                required: true,
                serializedName: "uri",
                type: {
                    name: "String"
                }
            }, httpHeaders: {
                serializedName: "httpHeaders",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, httpMethod: {
                serializedName: "httpMethod",
                type: {
                    name: "String"
                }
            }, timeout: {
                serializedName: "timeout",
                type: {
                    name: "TimeSpan"
                }
            }, batchSize: {
                nullable: true,
                serializedName: "batchSize",
                type: {
                    name: "Number"
                }
            }, degreeOfParallelism: {
                nullable: true,
                serializedName: "degreeOfParallelism",
                type: {
                    name: "Number"
                }
            } })
    }
};
const ListSkillsetsResult = {
    serializedName: "ListSkillsetsResult",
    type: {
        name: "Composite",
        className: "ListSkillsetsResult",
        modelProperties: {
            skillsets: {
                required: true,
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchIndexerSkillset"
                        }
                    }
                }
            }
        }
    }
};
const SynonymMap = {
    serializedName: "SynonymMap",
    type: {
        name: "Composite",
        className: "SynonymMap",
        modelProperties: {
            name: {
                required: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            format: {
                required: true,
                isConstant: true,
                serializedName: "format",
                defaultValue: 'solr',
                type: {
                    name: "String"
                }
            },
            synonyms: {
                required: true,
                serializedName: "synonyms",
                type: {
                    name: "String"
                }
            },
            encryptionKey: {
                serializedName: "encryptionKey",
                type: {
                    name: "Composite",
                    className: "SearchResourceEncryptionKey"
                }
            },
            etag: {
                serializedName: "@odata\\.etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListSynonymMapsResult = {
    serializedName: "ListSynonymMapsResult",
    type: {
        name: "Composite",
        className: "ListSynonymMapsResult",
        modelProperties: {
            synonymMaps: {
                required: true,
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SynonymMap"
                        }
                    }
                }
            }
        }
    }
};
const ResourceCounter = {
    serializedName: "ResourceCounter",
    type: {
        name: "Composite",
        className: "ResourceCounter",
        modelProperties: {
            usage: {
                required: true,
                nullable: false,
                serializedName: "usage",
                type: {
                    name: "Number"
                }
            },
            quota: {
                nullable: true,
                serializedName: "quota",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceCounters = {
    serializedName: "ServiceCounters",
    type: {
        name: "Composite",
        className: "ServiceCounters",
        modelProperties: {
            documentCounter: {
                required: true,
                serializedName: "documentCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            indexCounter: {
                required: true,
                serializedName: "indexesCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            indexerCounter: {
                required: true,
                serializedName: "indexersCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            dataSourceCounter: {
                required: true,
                serializedName: "dataSourcesCount",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            storageSizeCounter: {
                required: true,
                serializedName: "storageSize",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            },
            synonymMapCounter: {
                required: true,
                serializedName: "synonymMaps",
                type: {
                    name: "Composite",
                    className: "ResourceCounter"
                }
            }
        }
    }
};
const ServiceLimits = {
    serializedName: "ServiceLimits",
    type: {
        name: "Composite",
        className: "ServiceLimits",
        modelProperties: {
            maxFieldsPerIndex: {
                nullable: true,
                serializedName: "maxFieldsPerIndex",
                type: {
                    name: "Number"
                }
            },
            maxFieldNestingDepthPerIndex: {
                nullable: true,
                serializedName: "maxFieldNestingDepthPerIndex",
                type: {
                    name: "Number"
                }
            },
            maxComplexCollectionFieldsPerIndex: {
                nullable: true,
                serializedName: "maxComplexCollectionFieldsPerIndex",
                type: {
                    name: "Number"
                }
            },
            maxComplexObjectsInCollectionsPerDocument: {
                nullable: true,
                serializedName: "maxComplexObjectsInCollectionsPerDocument",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceStatistics = {
    serializedName: "ServiceStatistics",
    type: {
        name: "Composite",
        className: "ServiceStatistics",
        modelProperties: {
            counters: {
                required: true,
                serializedName: "counters",
                type: {
                    name: "Composite",
                    className: "ServiceCounters"
                }
            },
            limits: {
                required: true,
                serializedName: "limits",
                type: {
                    name: "Composite",
                    className: "ServiceLimits"
                }
            }
        }
    }
};
const SearchError$1 = {
    serializedName: "SearchError",
    type: {
        name: "Composite",
        className: "SearchError",
        modelProperties: {
            code: {
                readOnly: true,
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                required: true,
                readOnly: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            details: {
                readOnly: true,
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchError"
                        }
                    }
                }
            }
        }
    }
};
const discriminators = {
    'LexicalAnalyzer': LexicalAnalyzer,
    'LexicalAnalyzer.#Microsoft.Azure.Search.CustomAnalyzer': CustomAnalyzer,
    'LexicalAnalyzer.#Microsoft.Azure.Search.PatternAnalyzer': PatternAnalyzer,
    'LexicalAnalyzer.#Microsoft.Azure.Search.StandardAnalyzer': LuceneStandardAnalyzer,
    'LexicalAnalyzer.#Microsoft.Azure.Search.StopAnalyzer': StopAnalyzer,
    'LexicalTokenizer': LexicalTokenizer,
    'LexicalTokenizer.#Microsoft.Azure.Search.ClassicTokenizer': ClassicTokenizer,
    'LexicalTokenizer.#Microsoft.Azure.Search.EdgeNGramTokenizer': EdgeNGramTokenizer,
    'LexicalTokenizer.#Microsoft.Azure.Search.KeywordTokenizer': KeywordTokenizer,
    'LexicalTokenizer.#Microsoft.Azure.Search.KeywordTokenizerV2': KeywordTokenizerV2,
    'LexicalTokenizer.#Microsoft.Azure.Search.MicrosoftLanguageTokenizer': MicrosoftLanguageTokenizer,
    'LexicalTokenizer.#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer': MicrosoftLanguageStemmingTokenizer,
    'LexicalTokenizer.#Microsoft.Azure.Search.NGramTokenizer': NGramTokenizer,
    'LexicalTokenizer.#Microsoft.Azure.Search.PathHierarchyTokenizerV2': PathHierarchyTokenizerV2,
    'LexicalTokenizer.#Microsoft.Azure.Search.PatternTokenizer': PatternTokenizer,
    'LexicalTokenizer.#Microsoft.Azure.Search.StandardTokenizer': LuceneStandardTokenizer,
    'LexicalTokenizer.#Microsoft.Azure.Search.StandardTokenizerV2': LuceneStandardTokenizerV2,
    'LexicalTokenizer.#Microsoft.Azure.Search.UaxUrlEmailTokenizer': UaxUrlEmailTokenizer,
    'TokenFilter': TokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.AsciiFoldingTokenFilter': AsciiFoldingTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.CjkBigramTokenFilter': CjkBigramTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.CommonGramTokenFilter': CommonGramTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter': DictionaryDecompounderTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.EdgeNGramTokenFilter': EdgeNGramTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.EdgeNGramTokenFilterV2': EdgeNGramTokenFilterV2,
    'TokenFilter.#Microsoft.Azure.Search.ElisionTokenFilter': ElisionTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.KeepTokenFilter': KeepTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.KeywordMarkerTokenFilter': KeywordMarkerTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.LengthTokenFilter': LengthTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.LimitTokenFilter': LimitTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.NGramTokenFilter': NGramTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.NGramTokenFilterV2': NGramTokenFilterV2,
    'TokenFilter.#Microsoft.Azure.Search.PatternCaptureTokenFilter': PatternCaptureTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.PatternReplaceTokenFilter': PatternReplaceTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.PhoneticTokenFilter': PhoneticTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.ShingleTokenFilter': ShingleTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.SnowballTokenFilter': SnowballTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.StemmerTokenFilter': StemmerTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.StemmerOverrideTokenFilter': StemmerOverrideTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.StopwordsTokenFilter': StopwordsTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.SynonymTokenFilter': SynonymTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.TruncateTokenFilter': TruncateTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.UniqueTokenFilter': UniqueTokenFilter,
    'TokenFilter.#Microsoft.Azure.Search.WordDelimiterTokenFilter': WordDelimiterTokenFilter,
    'CharFilter': CharFilter,
    'CharFilter.#Microsoft.Azure.Search.MappingCharFilter': MappingCharFilter,
    'CharFilter.#Microsoft.Azure.Search.PatternReplaceCharFilter': PatternReplaceCharFilter,
    'Similarity': Similarity,
    'Similarity.#Microsoft.Azure.Search.ClassicSimilarity': ClassicSimilarity,
    'Similarity.#Microsoft.Azure.Search.BM25Similarity': BM25Similarity,
    'DataChangeDetectionPolicy': DataChangeDetectionPolicy,
    'DataChangeDetectionPolicy.#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy': HighWaterMarkChangeDetectionPolicy,
    'DataChangeDetectionPolicy.#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy': SqlIntegratedChangeTrackingPolicy,
    'DataDeletionDetectionPolicy': DataDeletionDetectionPolicy,
    'DataDeletionDetectionPolicy.#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy': SoftDeleteColumnDeletionDetectionPolicy,
    'ScoringFunction': ScoringFunction,
    'ScoringFunction.distance': DistanceScoringFunction,
    'ScoringFunction.freshness': FreshnessScoringFunction,
    'ScoringFunction.magnitude': MagnitudeScoringFunction,
    'ScoringFunction.tag': TagScoringFunction,
    'SearchIndexerSkill': SearchIndexerSkill,
    'CognitiveServicesAccount': CognitiveServicesAccount,
    'CognitiveServicesAccount.#Microsoft.Azure.Search.DefaultCognitiveServices': DefaultCognitiveServicesAccount,
    'CognitiveServicesAccount.#Microsoft.Azure.Search.CognitiveServicesByKey': CognitiveServicesAccountKey,
    'SearchIndexerSkill.#Microsoft.Skills.Util.ConditionalSkill': ConditionalSkill,
    'SearchIndexerSkill.#Microsoft.Skills.Text.KeyPhraseExtractionSkill': KeyPhraseExtractionSkill,
    'SearchIndexerSkill.#Microsoft.Skills.Vision.OcrSkill': OcrSkill,
    'SearchIndexerSkill.#Microsoft.Skills.Vision.ImageAnalysisSkill': ImageAnalysisSkill,
    'SearchIndexerSkill.#Microsoft.Skills.Text.LanguageDetectionSkill': LanguageDetectionSkill,
    'SearchIndexerSkill.#Microsoft.Skills.Util.ShaperSkill': ShaperSkill,
    'SearchIndexerSkill.#Microsoft.Skills.Text.MergeSkill': MergeSkill,
    'SearchIndexerSkill.#Microsoft.Skills.Text.EntityRecognitionSkill': EntityRecognitionSkill,
    'SearchIndexerSkill.#Microsoft.Skills.Text.SentimentSkill': SentimentSkill,
    'SearchIndexerSkill.#Microsoft.Skills.Text.SplitSkill': SplitSkill,
    'SearchIndexerSkill.#Microsoft.Skills.Text.TranslationSkill': TextTranslationSkill,
    'SearchIndexerSkill.#Microsoft.Skills.Custom.WebApiSkill': WebApiSkill
};

var Mappers$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AnalyzeRequest: AnalyzeRequest,
    AnalyzedTokenInfo: AnalyzedTokenInfo,
    AnalyzeResult: AnalyzeResult,
    LexicalAnalyzer: LexicalAnalyzer,
    CustomAnalyzer: CustomAnalyzer,
    PatternAnalyzer: PatternAnalyzer,
    LuceneStandardAnalyzer: LuceneStandardAnalyzer,
    StopAnalyzer: StopAnalyzer,
    LexicalTokenizer: LexicalTokenizer,
    ClassicTokenizer: ClassicTokenizer,
    EdgeNGramTokenizer: EdgeNGramTokenizer,
    KeywordTokenizer: KeywordTokenizer,
    KeywordTokenizerV2: KeywordTokenizerV2,
    MicrosoftLanguageTokenizer: MicrosoftLanguageTokenizer,
    MicrosoftLanguageStemmingTokenizer: MicrosoftLanguageStemmingTokenizer,
    NGramTokenizer: NGramTokenizer,
    PathHierarchyTokenizerV2: PathHierarchyTokenizerV2,
    PatternTokenizer: PatternTokenizer,
    LuceneStandardTokenizer: LuceneStandardTokenizer,
    LuceneStandardTokenizerV2: LuceneStandardTokenizerV2,
    UaxUrlEmailTokenizer: UaxUrlEmailTokenizer,
    TokenFilter: TokenFilter,
    AsciiFoldingTokenFilter: AsciiFoldingTokenFilter,
    CjkBigramTokenFilter: CjkBigramTokenFilter,
    CommonGramTokenFilter: CommonGramTokenFilter,
    DictionaryDecompounderTokenFilter: DictionaryDecompounderTokenFilter,
    EdgeNGramTokenFilter: EdgeNGramTokenFilter,
    EdgeNGramTokenFilterV2: EdgeNGramTokenFilterV2,
    ElisionTokenFilter: ElisionTokenFilter,
    KeepTokenFilter: KeepTokenFilter,
    KeywordMarkerTokenFilter: KeywordMarkerTokenFilter,
    LengthTokenFilter: LengthTokenFilter,
    LimitTokenFilter: LimitTokenFilter,
    NGramTokenFilter: NGramTokenFilter,
    NGramTokenFilterV2: NGramTokenFilterV2,
    PatternCaptureTokenFilter: PatternCaptureTokenFilter,
    PatternReplaceTokenFilter: PatternReplaceTokenFilter,
    PhoneticTokenFilter: PhoneticTokenFilter,
    ShingleTokenFilter: ShingleTokenFilter,
    SnowballTokenFilter: SnowballTokenFilter,
    StemmerTokenFilter: StemmerTokenFilter,
    StemmerOverrideTokenFilter: StemmerOverrideTokenFilter,
    StopwordsTokenFilter: StopwordsTokenFilter,
    SynonymTokenFilter: SynonymTokenFilter,
    TruncateTokenFilter: TruncateTokenFilter,
    UniqueTokenFilter: UniqueTokenFilter,
    WordDelimiterTokenFilter: WordDelimiterTokenFilter,
    CharFilter: CharFilter,
    MappingCharFilter: MappingCharFilter,
    PatternReplaceCharFilter: PatternReplaceCharFilter,
    Similarity: Similarity,
    ClassicSimilarity: ClassicSimilarity,
    BM25Similarity: BM25Similarity,
    DataSourceCredentials: DataSourceCredentials,
    SearchIndexerDataContainer: SearchIndexerDataContainer,
    DataChangeDetectionPolicy: DataChangeDetectionPolicy,
    HighWaterMarkChangeDetectionPolicy: HighWaterMarkChangeDetectionPolicy,
    SqlIntegratedChangeTrackingPolicy: SqlIntegratedChangeTrackingPolicy,
    DataDeletionDetectionPolicy: DataDeletionDetectionPolicy,
    SoftDeleteColumnDeletionDetectionPolicy: SoftDeleteColumnDeletionDetectionPolicy,
    SearchIndexerDataSource: SearchIndexerDataSource,
    ListDataSourcesResult: ListDataSourcesResult,
    IndexingSchedule: IndexingSchedule,
    IndexingParameters: IndexingParameters,
    FieldMappingFunction: FieldMappingFunction,
    FieldMapping: FieldMapping,
    SearchIndexer: SearchIndexer,
    ListIndexersResult: ListIndexersResult,
    SearchIndexerError: SearchIndexerError,
    SearchIndexerWarning: SearchIndexerWarning,
    IndexerExecutionResult: IndexerExecutionResult,
    SearchIndexerLimits: SearchIndexerLimits,
    SearchIndexerStatus: SearchIndexerStatus,
    SearchField: SearchField,
    TextWeights: TextWeights,
    ScoringFunction: ScoringFunction,
    DistanceScoringParameters: DistanceScoringParameters,
    DistanceScoringFunction: DistanceScoringFunction,
    FreshnessScoringParameters: FreshnessScoringParameters,
    FreshnessScoringFunction: FreshnessScoringFunction,
    MagnitudeScoringParameters: MagnitudeScoringParameters,
    MagnitudeScoringFunction: MagnitudeScoringFunction,
    TagScoringParameters: TagScoringParameters,
    TagScoringFunction: TagScoringFunction,
    ScoringProfile: ScoringProfile,
    CorsOptions: CorsOptions,
    Suggester: Suggester,
    AzureActiveDirectoryApplicationCredentials: AzureActiveDirectoryApplicationCredentials,
    SearchResourceEncryptionKey: SearchResourceEncryptionKey,
    SearchIndex: SearchIndex,
    GetIndexStatisticsResult: GetIndexStatisticsResult,
    ListIndexesResult: ListIndexesResult,
    InputFieldMappingEntry: InputFieldMappingEntry,
    OutputFieldMappingEntry: OutputFieldMappingEntry,
    SearchIndexerSkill: SearchIndexerSkill,
    CognitiveServicesAccount: CognitiveServicesAccount,
    SearchIndexerSkillset: SearchIndexerSkillset,
    DefaultCognitiveServicesAccount: DefaultCognitiveServicesAccount,
    CognitiveServicesAccountKey: CognitiveServicesAccountKey,
    ConditionalSkill: ConditionalSkill,
    KeyPhraseExtractionSkill: KeyPhraseExtractionSkill,
    OcrSkill: OcrSkill,
    ImageAnalysisSkill: ImageAnalysisSkill,
    LanguageDetectionSkill: LanguageDetectionSkill,
    ShaperSkill: ShaperSkill,
    MergeSkill: MergeSkill,
    EntityRecognitionSkill: EntityRecognitionSkill,
    SentimentSkill: SentimentSkill,
    SplitSkill: SplitSkill,
    TextTranslationSkill: TextTranslationSkill,
    WebApiSkill: WebApiSkill,
    ListSkillsetsResult: ListSkillsetsResult,
    SynonymMap: SynonymMap,
    ListSynonymMapsResult: ListSynonymMapsResult,
    ResourceCounter: ResourceCounter,
    ServiceCounters: ServiceCounters,
    ServiceLimits: ServiceLimits,
    ServiceStatistics: ServiceStatistics,
    SearchError: SearchError$1,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
const allowIndexDowntime = {
    parameterPath: [
        "options",
        "allowIndexDowntime"
    ],
    mapper: {
        serializedName: "allowIndexDowntime",
        type: {
            name: "Boolean"
        }
    }
};
const apiVersion$1 = {
    parameterPath: "apiVersion",
    mapper: {
        required: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const dataSourceName = {
    parameterPath: "dataSourceName",
    mapper: {
        required: true,
        serializedName: "dataSourceName",
        type: {
            name: "String"
        }
    }
};
const endpoint$1 = {
    parameterPath: "endpoint",
    mapper: {
        required: true,
        serializedName: "endpoint",
        defaultValue: '',
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const ifMatch = {
    parameterPath: [
        "options",
        "ifMatch"
    ],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const ifNoneMatch = {
    parameterPath: [
        "options",
        "ifNoneMatch"
    ],
    mapper: {
        serializedName: "If-None-Match",
        type: {
            name: "String"
        }
    }
};
const indexerName = {
    parameterPath: "indexerName",
    mapper: {
        required: true,
        serializedName: "indexerName",
        type: {
            name: "String"
        }
    }
};
const indexName$1 = {
    parameterPath: "indexName",
    mapper: {
        required: true,
        serializedName: "indexName",
        type: {
            name: "String"
        }
    }
};
const prefer = {
    parameterPath: "prefer",
    mapper: {
        required: true,
        isConstant: true,
        serializedName: "Prefer",
        defaultValue: 'return=representation',
        type: {
            name: "String"
        }
    }
};
const select = {
    parameterPath: [
        "options",
        "select"
    ],
    mapper: {
        serializedName: "$select",
        type: {
            name: "String"
        }
    }
};
const skillsetName = {
    parameterPath: "skillsetName",
    mapper: {
        required: true,
        serializedName: "skillsetName",
        type: {
            name: "String"
        }
    }
};
const synonymMapName = {
    parameterPath: "synonymMapName",
    mapper: {
        required: true,
        serializedName: "synonymMapName",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    discriminators: discriminators,
    DataChangeDetectionPolicy: DataChangeDetectionPolicy,
    DataDeletionDetectionPolicy: DataDeletionDetectionPolicy,
    DataSourceCredentials: DataSourceCredentials,
    HighWaterMarkChangeDetectionPolicy: HighWaterMarkChangeDetectionPolicy,
    ListDataSourcesResult: ListDataSourcesResult,
    SearchError: SearchError$1,
    SearchIndexerDataContainer: SearchIndexerDataContainer,
    SearchIndexerDataSource: SearchIndexerDataSource,
    SoftDeleteColumnDeletionDetectionPolicy: SoftDeleteColumnDeletionDetectionPolicy,
    SqlIntegratedChangeTrackingPolicy: SqlIntegratedChangeTrackingPolicy
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a DataSources. */
class DataSources {
    /**
     * Create a DataSources.
     * @param {SearchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    createOrUpdate(dataSourceName, dataSource, options, callback) {
        return this.client.sendOperationRequest({
            dataSourceName,
            dataSource,
            options
        }, createOrUpdateOperationSpec, callback);
    }
    deleteMethod(dataSourceName, options, callback) {
        return this.client.sendOperationRequest({
            dataSourceName,
            options
        }, deleteMethodOperationSpec, callback);
    }
    get(dataSourceName, options, callback) {
        return this.client.sendOperationRequest({
            dataSourceName,
            options
        }, getOperationSpec$1, callback);
    }
    list(options, callback) {
        return this.client.sendOperationRequest({
            options
        }, listOperationSpec, callback);
    }
    create(dataSource, options, callback) {
        return this.client.sendOperationRequest({
            dataSource,
            options
        }, createOperationSpec, callback);
    }
}
// Operation Specifications
const serializer$1 = new coreHttp.Serializer(Mappers$2);
const createOrUpdateOperationSpec = {
    httpMethod: "PUT",
    path: "datasources('{dataSourceName}')",
    urlParameters: [
        endpoint$1,
        dataSourceName
    ],
    queryParameters: [
        apiVersion$1
    ],
    headerParameters: [
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    requestBody: {
        parameterPath: "dataSource",
        mapper: Object.assign(Object.assign({}, SearchIndexerDataSource), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SearchIndexerDataSource
        },
        201: {
            bodyMapper: SearchIndexerDataSource
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$1
};
const deleteMethodOperationSpec = {
    httpMethod: "DELETE",
    path: "datasources('{dataSourceName}')",
    urlParameters: [
        endpoint$1,
        dataSourceName
    ],
    queryParameters: [
        apiVersion$1
    ],
    headerParameters: [
        ifMatch,
        ifNoneMatch
    ],
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$1
};
const getOperationSpec$1 = {
    httpMethod: "GET",
    path: "datasources('{dataSourceName}')",
    urlParameters: [
        endpoint$1,
        dataSourceName
    ],
    queryParameters: [
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: SearchIndexerDataSource
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$1
};
const listOperationSpec = {
    httpMethod: "GET",
    path: "datasources",
    urlParameters: [
        endpoint$1
    ],
    queryParameters: [
        select,
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: ListDataSourcesResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$1
};
const createOperationSpec = {
    httpMethod: "POST",
    path: "datasources",
    urlParameters: [
        endpoint$1
    ],
    queryParameters: [
        apiVersion$1
    ],
    requestBody: {
        parameterPath: "dataSource",
        mapper: Object.assign(Object.assign({}, SearchIndexerDataSource), { required: true })
    },
    responses: {
        201: {
            bodyMapper: SearchIndexerDataSource
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    discriminators: discriminators,
    FieldMapping: FieldMapping,
    FieldMappingFunction: FieldMappingFunction,
    IndexerExecutionResult: IndexerExecutionResult,
    IndexingParameters: IndexingParameters,
    IndexingSchedule: IndexingSchedule,
    ListIndexersResult: ListIndexersResult,
    SearchError: SearchError$1,
    SearchIndexer: SearchIndexer,
    SearchIndexerError: SearchIndexerError,
    SearchIndexerLimits: SearchIndexerLimits,
    SearchIndexerStatus: SearchIndexerStatus,
    SearchIndexerWarning: SearchIndexerWarning
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a Indexers. */
class Indexers {
    /**
     * Create a Indexers.
     * @param {SearchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    reset(indexerName, options, callback) {
        return this.client.sendOperationRequest({
            indexerName,
            options
        }, resetOperationSpec, callback);
    }
    run(indexerName, options, callback) {
        return this.client.sendOperationRequest({
            indexerName,
            options
        }, runOperationSpec, callback);
    }
    createOrUpdate(indexerName, indexer, options, callback) {
        return this.client.sendOperationRequest({
            indexerName,
            indexer,
            options
        }, createOrUpdateOperationSpec$1, callback);
    }
    deleteMethod(indexerName, options, callback) {
        return this.client.sendOperationRequest({
            indexerName,
            options
        }, deleteMethodOperationSpec$1, callback);
    }
    get(indexerName, options, callback) {
        return this.client.sendOperationRequest({
            indexerName,
            options
        }, getOperationSpec$2, callback);
    }
    list(options, callback) {
        return this.client.sendOperationRequest({
            options
        }, listOperationSpec$1, callback);
    }
    create(indexer, options, callback) {
        return this.client.sendOperationRequest({
            indexer,
            options
        }, createOperationSpec$1, callback);
    }
    getStatus(indexerName, options, callback) {
        return this.client.sendOperationRequest({
            indexerName,
            options
        }, getStatusOperationSpec, callback);
    }
}
// Operation Specifications
const serializer$2 = new coreHttp.Serializer(Mappers$3);
const resetOperationSpec = {
    httpMethod: "POST",
    path: "indexers('{indexerName}')/search.reset",
    urlParameters: [
        endpoint$1,
        indexerName
    ],
    queryParameters: [
        apiVersion$1
    ],
    responses: {
        204: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$2
};
const runOperationSpec = {
    httpMethod: "POST",
    path: "indexers('{indexerName}')/search.run",
    urlParameters: [
        endpoint$1,
        indexerName
    ],
    queryParameters: [
        apiVersion$1
    ],
    responses: {
        202: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$2
};
const createOrUpdateOperationSpec$1 = {
    httpMethod: "PUT",
    path: "indexers('{indexerName}')",
    urlParameters: [
        endpoint$1,
        indexerName
    ],
    queryParameters: [
        apiVersion$1
    ],
    headerParameters: [
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    requestBody: {
        parameterPath: "indexer",
        mapper: Object.assign(Object.assign({}, SearchIndexer), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SearchIndexer
        },
        201: {
            bodyMapper: SearchIndexer
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$2
};
const deleteMethodOperationSpec$1 = {
    httpMethod: "DELETE",
    path: "indexers('{indexerName}')",
    urlParameters: [
        endpoint$1,
        indexerName
    ],
    queryParameters: [
        apiVersion$1
    ],
    headerParameters: [
        ifMatch,
        ifNoneMatch
    ],
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$2
};
const getOperationSpec$2 = {
    httpMethod: "GET",
    path: "indexers('{indexerName}')",
    urlParameters: [
        endpoint$1,
        indexerName
    ],
    queryParameters: [
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: SearchIndexer
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$2
};
const listOperationSpec$1 = {
    httpMethod: "GET",
    path: "indexers",
    urlParameters: [
        endpoint$1
    ],
    queryParameters: [
        select,
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: ListIndexersResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$2
};
const createOperationSpec$1 = {
    httpMethod: "POST",
    path: "indexers",
    urlParameters: [
        endpoint$1
    ],
    queryParameters: [
        apiVersion$1
    ],
    requestBody: {
        parameterPath: "indexer",
        mapper: Object.assign(Object.assign({}, SearchIndexer), { required: true })
    },
    responses: {
        201: {
            bodyMapper: SearchIndexer
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$2
};
const getStatusOperationSpec = {
    httpMethod: "GET",
    path: "indexers('{indexerName}')/search.status",
    urlParameters: [
        endpoint$1,
        indexerName
    ],
    queryParameters: [
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: SearchIndexerStatus
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    discriminators: discriminators,
    CognitiveServicesAccount: CognitiveServicesAccount,
    CognitiveServicesAccountKey: CognitiveServicesAccountKey,
    ConditionalSkill: ConditionalSkill,
    DefaultCognitiveServicesAccount: DefaultCognitiveServicesAccount,
    EntityRecognitionSkill: EntityRecognitionSkill,
    ImageAnalysisSkill: ImageAnalysisSkill,
    InputFieldMappingEntry: InputFieldMappingEntry,
    KeyPhraseExtractionSkill: KeyPhraseExtractionSkill,
    LanguageDetectionSkill: LanguageDetectionSkill,
    ListSkillsetsResult: ListSkillsetsResult,
    MergeSkill: MergeSkill,
    OcrSkill: OcrSkill,
    OutputFieldMappingEntry: OutputFieldMappingEntry,
    SearchError: SearchError$1,
    SearchIndexerSkill: SearchIndexerSkill,
    SearchIndexerSkillset: SearchIndexerSkillset,
    SentimentSkill: SentimentSkill,
    ShaperSkill: ShaperSkill,
    SplitSkill: SplitSkill,
    TextTranslationSkill: TextTranslationSkill,
    WebApiSkill: WebApiSkill
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a Skillsets. */
class Skillsets {
    /**
     * Create a Skillsets.
     * @param {SearchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    createOrUpdate(skillsetName, skillset, options, callback) {
        return this.client.sendOperationRequest({
            skillsetName,
            skillset,
            options
        }, createOrUpdateOperationSpec$2, callback);
    }
    deleteMethod(skillsetName, options, callback) {
        return this.client.sendOperationRequest({
            skillsetName,
            options
        }, deleteMethodOperationSpec$2, callback);
    }
    get(skillsetName, options, callback) {
        return this.client.sendOperationRequest({
            skillsetName,
            options
        }, getOperationSpec$3, callback);
    }
    list(options, callback) {
        return this.client.sendOperationRequest({
            options
        }, listOperationSpec$2, callback);
    }
    create(skillset, options, callback) {
        return this.client.sendOperationRequest({
            skillset,
            options
        }, createOperationSpec$2, callback);
    }
}
// Operation Specifications
const serializer$3 = new coreHttp.Serializer(Mappers$4);
const createOrUpdateOperationSpec$2 = {
    httpMethod: "PUT",
    path: "skillsets('{skillsetName}')",
    urlParameters: [
        endpoint$1,
        skillsetName
    ],
    queryParameters: [
        apiVersion$1
    ],
    headerParameters: [
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    requestBody: {
        parameterPath: "skillset",
        mapper: Object.assign(Object.assign({}, SearchIndexerSkillset), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SearchIndexerSkillset
        },
        201: {
            bodyMapper: SearchIndexerSkillset
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$3
};
const deleteMethodOperationSpec$2 = {
    httpMethod: "DELETE",
    path: "skillsets('{skillsetName}')",
    urlParameters: [
        endpoint$1,
        skillsetName
    ],
    queryParameters: [
        apiVersion$1
    ],
    headerParameters: [
        ifMatch,
        ifNoneMatch
    ],
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$3
};
const getOperationSpec$3 = {
    httpMethod: "GET",
    path: "skillsets('{skillsetName}')",
    urlParameters: [
        endpoint$1,
        skillsetName
    ],
    queryParameters: [
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: SearchIndexerSkillset
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$3
};
const listOperationSpec$2 = {
    httpMethod: "GET",
    path: "skillsets",
    urlParameters: [
        endpoint$1
    ],
    queryParameters: [
        select,
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: ListSkillsetsResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$3
};
const createOperationSpec$2 = {
    httpMethod: "POST",
    path: "skillsets",
    urlParameters: [
        endpoint$1
    ],
    queryParameters: [
        apiVersion$1
    ],
    requestBody: {
        parameterPath: "skillset",
        mapper: Object.assign(Object.assign({}, SearchIndexerSkillset), { required: true })
    },
    responses: {
        201: {
            bodyMapper: SearchIndexerSkillset
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers$5 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    discriminators: discriminators,
    AzureActiveDirectoryApplicationCredentials: AzureActiveDirectoryApplicationCredentials,
    ListSynonymMapsResult: ListSynonymMapsResult,
    SearchError: SearchError$1,
    SearchResourceEncryptionKey: SearchResourceEncryptionKey,
    SynonymMap: SynonymMap
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a SynonymMaps. */
class SynonymMaps {
    /**
     * Create a SynonymMaps.
     * @param {SearchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    createOrUpdate(synonymMapName, synonymMap, options, callback) {
        return this.client.sendOperationRequest({
            synonymMapName,
            synonymMap,
            options
        }, createOrUpdateOperationSpec$3, callback);
    }
    deleteMethod(synonymMapName, options, callback) {
        return this.client.sendOperationRequest({
            synonymMapName,
            options
        }, deleteMethodOperationSpec$3, callback);
    }
    get(synonymMapName, options, callback) {
        return this.client.sendOperationRequest({
            synonymMapName,
            options
        }, getOperationSpec$4, callback);
    }
    list(options, callback) {
        return this.client.sendOperationRequest({
            options
        }, listOperationSpec$3, callback);
    }
    create(synonymMap, options, callback) {
        return this.client.sendOperationRequest({
            synonymMap,
            options
        }, createOperationSpec$3, callback);
    }
}
// Operation Specifications
const serializer$4 = new coreHttp.Serializer(Mappers$5);
const createOrUpdateOperationSpec$3 = {
    httpMethod: "PUT",
    path: "synonymmaps('{synonymMapName}')",
    urlParameters: [
        endpoint$1,
        synonymMapName
    ],
    queryParameters: [
        apiVersion$1
    ],
    headerParameters: [
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    requestBody: {
        parameterPath: "synonymMap",
        mapper: Object.assign(Object.assign({}, SynonymMap), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SynonymMap
        },
        201: {
            bodyMapper: SynonymMap
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$4
};
const deleteMethodOperationSpec$3 = {
    httpMethod: "DELETE",
    path: "synonymmaps('{synonymMapName}')",
    urlParameters: [
        endpoint$1,
        synonymMapName
    ],
    queryParameters: [
        apiVersion$1
    ],
    headerParameters: [
        ifMatch,
        ifNoneMatch
    ],
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$4
};
const getOperationSpec$4 = {
    httpMethod: "GET",
    path: "synonymmaps('{synonymMapName}')",
    urlParameters: [
        endpoint$1,
        synonymMapName
    ],
    queryParameters: [
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: SynonymMap
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$4
};
const listOperationSpec$3 = {
    httpMethod: "GET",
    path: "synonymmaps",
    urlParameters: [
        endpoint$1
    ],
    queryParameters: [
        select,
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: ListSynonymMapsResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$4
};
const createOperationSpec$3 = {
    httpMethod: "POST",
    path: "synonymmaps",
    urlParameters: [
        endpoint$1
    ],
    queryParameters: [
        apiVersion$1
    ],
    requestBody: {
        parameterPath: "synonymMap",
        mapper: Object.assign(Object.assign({}, SynonymMap), { required: true })
    },
    responses: {
        201: {
            bodyMapper: SynonymMap
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var Mappers$6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    discriminators: discriminators,
    AnalyzedTokenInfo: AnalyzedTokenInfo,
    AnalyzeRequest: AnalyzeRequest,
    AnalyzeResult: AnalyzeResult,
    AsciiFoldingTokenFilter: AsciiFoldingTokenFilter,
    AzureActiveDirectoryApplicationCredentials: AzureActiveDirectoryApplicationCredentials,
    BM25Similarity: BM25Similarity,
    CharFilter: CharFilter,
    CjkBigramTokenFilter: CjkBigramTokenFilter,
    ClassicSimilarity: ClassicSimilarity,
    ClassicTokenizer: ClassicTokenizer,
    CommonGramTokenFilter: CommonGramTokenFilter,
    CorsOptions: CorsOptions,
    CustomAnalyzer: CustomAnalyzer,
    DictionaryDecompounderTokenFilter: DictionaryDecompounderTokenFilter,
    DistanceScoringFunction: DistanceScoringFunction,
    DistanceScoringParameters: DistanceScoringParameters,
    EdgeNGramTokenFilter: EdgeNGramTokenFilter,
    EdgeNGramTokenFilterV2: EdgeNGramTokenFilterV2,
    EdgeNGramTokenizer: EdgeNGramTokenizer,
    ElisionTokenFilter: ElisionTokenFilter,
    FreshnessScoringFunction: FreshnessScoringFunction,
    FreshnessScoringParameters: FreshnessScoringParameters,
    GetIndexStatisticsResult: GetIndexStatisticsResult,
    KeepTokenFilter: KeepTokenFilter,
    KeywordMarkerTokenFilter: KeywordMarkerTokenFilter,
    KeywordTokenizer: KeywordTokenizer,
    KeywordTokenizerV2: KeywordTokenizerV2,
    LengthTokenFilter: LengthTokenFilter,
    LexicalAnalyzer: LexicalAnalyzer,
    LexicalTokenizer: LexicalTokenizer,
    LimitTokenFilter: LimitTokenFilter,
    ListIndexesResult: ListIndexesResult,
    LuceneStandardAnalyzer: LuceneStandardAnalyzer,
    LuceneStandardTokenizer: LuceneStandardTokenizer,
    LuceneStandardTokenizerV2: LuceneStandardTokenizerV2,
    MagnitudeScoringFunction: MagnitudeScoringFunction,
    MagnitudeScoringParameters: MagnitudeScoringParameters,
    MappingCharFilter: MappingCharFilter,
    MicrosoftLanguageStemmingTokenizer: MicrosoftLanguageStemmingTokenizer,
    MicrosoftLanguageTokenizer: MicrosoftLanguageTokenizer,
    NGramTokenFilter: NGramTokenFilter,
    NGramTokenFilterV2: NGramTokenFilterV2,
    NGramTokenizer: NGramTokenizer,
    PathHierarchyTokenizerV2: PathHierarchyTokenizerV2,
    PatternAnalyzer: PatternAnalyzer,
    PatternCaptureTokenFilter: PatternCaptureTokenFilter,
    PatternReplaceCharFilter: PatternReplaceCharFilter,
    PatternReplaceTokenFilter: PatternReplaceTokenFilter,
    PatternTokenizer: PatternTokenizer,
    PhoneticTokenFilter: PhoneticTokenFilter,
    ScoringFunction: ScoringFunction,
    ScoringProfile: ScoringProfile,
    SearchError: SearchError$1,
    SearchField: SearchField,
    SearchIndex: SearchIndex,
    SearchResourceEncryptionKey: SearchResourceEncryptionKey,
    ShingleTokenFilter: ShingleTokenFilter,
    Similarity: Similarity,
    SnowballTokenFilter: SnowballTokenFilter,
    StemmerOverrideTokenFilter: StemmerOverrideTokenFilter,
    StemmerTokenFilter: StemmerTokenFilter,
    StopAnalyzer: StopAnalyzer,
    StopwordsTokenFilter: StopwordsTokenFilter,
    Suggester: Suggester,
    SynonymTokenFilter: SynonymTokenFilter,
    TagScoringFunction: TagScoringFunction,
    TagScoringParameters: TagScoringParameters,
    TextWeights: TextWeights,
    TokenFilter: TokenFilter,
    TruncateTokenFilter: TruncateTokenFilter,
    UaxUrlEmailTokenizer: UaxUrlEmailTokenizer,
    UniqueTokenFilter: UniqueTokenFilter,
    WordDelimiterTokenFilter: WordDelimiterTokenFilter
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/** Class representing a Indexes. */
class Indexes {
    /**
     * Create a Indexes.
     * @param {SearchServiceClientContext} client Reference to the service client.
     */
    constructor(client) {
        this.client = client;
    }
    create(index, options, callback) {
        return this.client.sendOperationRequest({
            index,
            options
        }, createOperationSpec$4, callback);
    }
    list(options, callback) {
        return this.client.sendOperationRequest({
            options
        }, listOperationSpec$4, callback);
    }
    createOrUpdate(indexName, index, options, callback) {
        return this.client.sendOperationRequest({
            indexName,
            index,
            options
        }, createOrUpdateOperationSpec$4, callback);
    }
    deleteMethod(indexName, options, callback) {
        return this.client.sendOperationRequest({
            indexName,
            options
        }, deleteMethodOperationSpec$4, callback);
    }
    get(indexName, options, callback) {
        return this.client.sendOperationRequest({
            indexName,
            options
        }, getOperationSpec$5, callback);
    }
    getStatistics(indexName, options, callback) {
        return this.client.sendOperationRequest({
            indexName,
            options
        }, getStatisticsOperationSpec, callback);
    }
    analyze(indexName, request, options, callback) {
        return this.client.sendOperationRequest({
            indexName,
            request,
            options
        }, analyzeOperationSpec, callback);
    }
}
// Operation Specifications
const serializer$5 = new coreHttp.Serializer(Mappers$6);
const createOperationSpec$4 = {
    httpMethod: "POST",
    path: "indexes",
    urlParameters: [
        endpoint$1
    ],
    queryParameters: [
        apiVersion$1
    ],
    requestBody: {
        parameterPath: "index",
        mapper: Object.assign(Object.assign({}, SearchIndex), { required: true })
    },
    responses: {
        201: {
            bodyMapper: SearchIndex
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$5
};
const listOperationSpec$4 = {
    httpMethod: "GET",
    path: "indexes",
    urlParameters: [
        endpoint$1
    ],
    queryParameters: [
        select,
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: ListIndexesResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$5
};
const createOrUpdateOperationSpec$4 = {
    httpMethod: "PUT",
    path: "indexes('{indexName}')",
    urlParameters: [
        endpoint$1,
        indexName$1
    ],
    queryParameters: [
        allowIndexDowntime,
        apiVersion$1
    ],
    headerParameters: [
        ifMatch,
        ifNoneMatch,
        prefer
    ],
    requestBody: {
        parameterPath: "index",
        mapper: Object.assign(Object.assign({}, SearchIndex), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SearchIndex
        },
        201: {
            bodyMapper: SearchIndex
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$5
};
const deleteMethodOperationSpec$4 = {
    httpMethod: "DELETE",
    path: "indexes('{indexName}')",
    urlParameters: [
        endpoint$1,
        indexName$1
    ],
    queryParameters: [
        apiVersion$1
    ],
    headerParameters: [
        ifMatch,
        ifNoneMatch
    ],
    responses: {
        204: {},
        404: {},
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$5
};
const getOperationSpec$5 = {
    httpMethod: "GET",
    path: "indexes('{indexName}')",
    urlParameters: [
        endpoint$1,
        indexName$1
    ],
    queryParameters: [
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: SearchIndex
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$5
};
const getStatisticsOperationSpec = {
    httpMethod: "GET",
    path: "indexes('{indexName}')/search.stats",
    urlParameters: [
        endpoint$1,
        indexName$1
    ],
    queryParameters: [
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: GetIndexStatisticsResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$5
};
const analyzeOperationSpec = {
    httpMethod: "POST",
    path: "indexes('{indexName}')/search.analyze",
    urlParameters: [
        endpoint$1,
        indexName$1
    ],
    queryParameters: [
        apiVersion$1
    ],
    requestBody: {
        parameterPath: "request",
        mapper: Object.assign(Object.assign({}, AnalyzeRequest), { required: true })
    },
    responses: {
        200: {
            bodyMapper: AnalyzeResult
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
const packageName$1 = "@azure/search-documents";
const packageVersion$1 = "11.0.3";
class SearchServiceClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the SearchServiceClientContext class.
     * @param apiVersion Client Api Version.
     * @param endpoint The endpoint URL of the search service.
     * @param [options] The parameter options
     */
    constructor(apiVersion, endpoint, options) {
        if (apiVersion == undefined) {
            throw new Error("'apiVersion' cannot be null.");
        }
        if (endpoint == undefined) {
            throw new Error("'endpoint' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName$1}/${packageVersion$1} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.baseUri = "{endpoint}";
        this.requestContentType = "application/json; charset=utf-8";
        this.apiVersion = apiVersion;
        this.endpoint = endpoint;
    }
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
class SearchServiceClient extends SearchServiceClientContext {
    /**
     * Initializes a new instance of the SearchServiceClient class.
     * @param apiVersion Client Api Version.
     * @param endpoint The endpoint URL of the search service.
     * @param [options] The parameter options
     */
    constructor(apiVersion, endpoint, options) {
        super(apiVersion, endpoint, options);
        this.dataSources = new DataSources(this);
        this.indexers = new Indexers(this);
        this.skillsets = new Skillsets(this);
        this.synonymMaps = new SynonymMaps(this);
        this.indexes = new Indexes(this);
    }
    getServiceStatistics(options, callback) {
        return this.sendOperationRequest({
            options
        }, getServiceStatisticsOperationSpec, callback);
    }
}
// Operation Specifications
const serializer$6 = new coreHttp.Serializer(Mappers$1);
const getServiceStatisticsOperationSpec = {
    httpMethod: "GET",
    path: "servicestats",
    urlParameters: [
        endpoint$1
    ],
    queryParameters: [
        apiVersion$1
    ],
    responses: {
        200: {
            bodyMapper: ServiceStatistics
        },
        default: {
            bodyMapper: SearchError$1
        }
    },
    serializer: serializer$6
};

// Copyright (c) Microsoft Corporation.
/**
 * Class to perform operations to manage
 * (create, update, list/delete)
 * indexes, & synonymmaps.
 */
class SearchIndexClient {
    /**
     * Creates an instance of SearchIndexClient.
     *
     * Example usage:
     * ```ts
     * const { SearchIndexClient, AzureKeyCredential } = require("@azure/search-documents");
     *
     * const client = new SearchIndexClient(
     *   "<endpoint>",
     *   new AzureKeyCredential("<Admin Key>");
     * );
     * ```
     * @param {string} endpoint The endpoint of the search service
     * @param {KeyCredential} credential Used to authenticate requests to the service.
     * @param {SearchIndexClientOptions} [options] Used to configure the Search Index client.
     */
    constructor(endpoint, credential, options = {}) {
        /**
         * The API version to use when communicating with the service.
         */
        this.apiVersion = "2020-06-30";
        this.endpoint = endpoint;
        this.credential = credential;
        this.options = options;
        const libInfo = `azsdk-js-search-documents/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        if (options.userAgentOptions.userAgentPrefix) {
            options.userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            options.userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: [
                    "elapsed-time",
                    "Location",
                    "OData-MaxVersion",
                    "OData-Version",
                    "Prefer",
                    "throttle-reason"
                ]
            }
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, createSearchApiKeyCredentialPolicy(credential));
        if (Array.isArray(pipeline.requestPolicyFactories)) {
            pipeline.requestPolicyFactories.unshift(odataMetadataPolicy("minimal"));
        }
        this.client = new SearchServiceClient(this.apiVersion, this.endpoint, pipeline);
    }
    listIndexesPage(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesPage_1() {
            const { span, updatedOptions } = createSpan("SearchIndexClient-listIndexesPage", options);
            try {
                const result = yield tslib.__await(this.client.indexes.list(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)));
                const mapped = result.indexes.map(generatedIndexToPublicIndex);
                yield yield tslib.__await(mapped);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listIndexesAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listIndexesPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves a list of existing indexes in the service.
     * @param options Options to the list index operation.
     */
    listIndexes(options = {}) {
        const iter = this.listIndexesAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listIndexesPage(options);
            }
        };
    }
    listIndexesNamesPage(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesNamesPage_1() {
            const { span, updatedOptions } = createSpan("SearchIndexClient-listIndexesNamesPage", options);
            try {
                const result = yield tslib.__await(this.client.indexes.list(Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" })));
                const mapped = result.indexes.map((idx) => idx.name);
                yield yield tslib.__await(mapped);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listIndexesNamesAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listIndexesNamesAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listIndexesNamesPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves a list of names of existing indexes in the service.
     * @param options Options to the list index operation.
     */
    listIndexesNames(options = {}) {
        const iter = this.listIndexesNamesAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listIndexesNamesPage(options);
            }
        };
    }
    /**
     * Retrieves a list of existing SynonymMaps in the service.
     * @param options Options to the list SynonymMaps operation.
     */
    listSynonymMaps(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-listSynonymMaps", options);
            try {
                const result = yield this.client.synonymMaps.list(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return result.synonymMaps.map(generatedSynonymMapToPublicSynonymMap);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves a list of names of existing SynonymMaps in the service.
     * @param options Options to the list SynonymMaps operation.
     */
    listSynonymMapsNames(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-listSynonymMapsNames", options);
            try {
                const result = yield this.client.synonymMaps.list(Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" }));
                return result.synonymMaps.map((sm) => sm.name);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves information about an index.
     * @param indexName The name of the index.
     * @param options Additional optional arguments.
     */
    getIndex(indexName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-getIndex", options);
            try {
                const result = yield this.client.indexes.get(indexName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return generatedIndexToPublicIndex(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves information about a SynonymMap.
     * @param synonymMapName The name of the SynonymMap.
     * @param options Additional optional arguments.
     */
    getSynonymMap(synonymMapName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-getSynonymMaps", options);
            try {
                const result = yield this.client.synonymMaps.get(synonymMapName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return generatedSynonymMapToPublicSynonymMap(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a new index.
     * @param index The information describing the index to be created.
     * @param options Additional optional arguments.
     */
    createIndex(index, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-createIndex", options);
            try {
                const result = yield this.client.indexes.create(publicIndexToGeneratedIndex(index), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return generatedIndexToPublicIndex(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a new SynonymMap in a search service.
     * @param synonymMap The synonymMap definition to create in a search service.
     * @param options Additional optional arguments.
     */
    createSynonymMap(synonymMap, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-createSynonymMaps", options);
            try {
                const result = yield this.client.synonymMaps.create(publicSynonymMapToGeneratedSynonymMap(synonymMap), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return generatedSynonymMapToPublicSynonymMap(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a new index or modifies an existing one.
     * @param index The information describing the index to be created.
     * @param options Additional optional arguments.
     */
    createOrUpdateIndex(index, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-createOrUpdateIndex", options);
            try {
                const etag = options.onlyIfUnchanged ? index.etag : undefined;
                const result = yield this.client.indexes.createOrUpdate(index.name, publicIndexToGeneratedIndex(index), Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
                return generatedIndexToPublicIndex(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a new SynonymMap or modifies an existing one.
     * @param synonymMap The information describing the SynonymMap to be created.
     * @param options Additional optional arguments.
     */
    createOrUpdateSynonymMap(synonymMap, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-createOrUpdateSynonymMap", options);
            try {
                const etag = options.onlyIfUnchanged ? synonymMap.etag : undefined;
                const result = yield this.client.synonymMaps.createOrUpdate(synonymMap.name, publicSynonymMapToGeneratedSynonymMap(synonymMap), Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
                return generatedSynonymMapToPublicSynonymMap(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Deletes an existing index.
     * @param indexName Index/Name of the index to delete.
     * @param options Additional optional arguments.
     */
    deleteIndex(index, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-deleteIndex", options);
            try {
                const indexName = typeof index === "string" ? index : index.name;
                const etag = typeof index === "string" ? undefined : options.onlyIfUnchanged ? index.etag : undefined;
                yield this.client.indexes.deleteMethod(indexName, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Deletes an existing SynonymMap.
     * @param synonymMapName SynonymMap/Name of the synonymMap to delete.
     * @param options Additional optional arguments.
     */
    deleteSynonymMap(synonymMap, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-deleteSynonymMap", options);
            try {
                const synonymMapName = typeof synonymMap === "string" ? synonymMap : synonymMap.name;
                const etag = typeof synonymMap === "string"
                    ? undefined
                    : options.onlyIfUnchanged
                        ? synonymMap.etag
                        : undefined;
                yield this.client.synonymMaps.deleteMethod(synonymMapName, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves statistics about an index, such as the count of documents and the size
     * of index storage.
     * @param indexName The name of the index.
     * @param options Additional optional arguments.
     */
    getIndexStatistics(indexName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-getIndexStatistics", options);
            try {
                const result = yield this.client.indexes.getStatistics(indexName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Calls an analyzer or tokenizer manually on provided text.
     * @param indexName The name of the index that contains the field to analyze
     * @param text The text to break into tokens.
     * @param options Additional arguments
     */
    analyzeText(indexName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { operationOptions, restOptions } = extractOperationOptions(options);
            const { span, updatedOptions } = createSpan("SearchIndexClient-analyzeText", operationOptions);
            try {
                const result = yield this.client.indexes.analyze(indexName, Object.assign(Object.assign({}, restOptions), { analyzer: restOptions.analyzerName, tokenizer: restOptions.tokenizerName }), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves statistics about the service, such as the count of documents, index, etc.
     * @param options Additional optional arguments.
     */
    getServiceStatistics(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexClient-getServiceStatistics", options);
            try {
                const result = yield this.client.getServiceStatistics(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves the SearchClient corresponding to this SearchIndexClient
     * @param indexName Name of the index
     * @param options SearchClient Options
     */
    getSearchClient(indexName, options) {
        return new SearchClient$1(this.endpoint, indexName, this.credential, options || this.options);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class to perform operations to manage
 * (create, update, list/delete)
 * indexers, datasources & skillsets.
 */
class SearchIndexerClient {
    /**
     * Creates an instance of SearchIndexerClient.
     *
     * Example usage:
     * ```ts
     * const { SearchIndexerClient, AzureKeyCredential } = require("@azure/search-documents");
     *
     * const client = new SearchIndexerClient(
     *   "<endpoint>",
     *   new AzureKeyCredential("<Admin Key>");
     * );
     * ```
     * @param {string} endpoint The endpoint of the search service
     * @param {KeyCredential} credential Used to authenticate requests to the service.
     * @param {SearchIndexerClientOptions} [options] Used to configure the Search client.
     */
    constructor(endpoint, credential, options = {}) {
        /**
         * The API version to use when communicating with the service.
         */
        this.apiVersion = "2020-06-30";
        this.endpoint = endpoint;
        const libInfo = `azsdk-js-search-documents/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        if (options.userAgentOptions.userAgentPrefix) {
            options.userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            options.userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: [
                    "elapsed-time",
                    "Location",
                    "OData-MaxVersion",
                    "OData-Version",
                    "Prefer",
                    "throttle-reason"
                ]
            }
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, createSearchApiKeyCredentialPolicy(credential));
        if (Array.isArray(pipeline.requestPolicyFactories)) {
            pipeline.requestPolicyFactories.unshift(odataMetadataPolicy("minimal"));
        }
        this.client = new SearchServiceClient(this.apiVersion, this.endpoint, pipeline);
    }
    /**
     * Retrieves a list of existing indexers in the service.
     * @param options Options to the list indexers operation.
     */
    listIndexers(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-listIndexers", options);
            try {
                const result = yield this.client.indexers.list(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return result.indexers;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves a list of names of existing indexers in the service.
     * @param options Options to the list indexers operation.
     */
    listIndexersNames(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-listIndexersNames", options);
            try {
                const result = yield this.client.indexers.list(Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" }));
                return result.indexers.map((idx) => idx.name);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves a list of existing data sources in the service.
     * @param options Options to the list indexers operation.
     */
    listDataSourceConnections(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-listDataSourceConnections", options);
            try {
                const result = yield this.client.dataSources.list(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return result.dataSources.map(generatedDataSourceToPublicDataSource);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves a list of names of existing data sources in the service.
     * @param options Options to the list indexers operation.
     */
    listDataSourceConnectionsNames(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-listDataSourceConnectionsNames", options);
            try {
                const result = yield this.client.dataSources.list(Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" }));
                return result.dataSources.map((ds) => ds.name);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves a list of existing Skillsets in the service.
     * @param options Options to the list Skillsets operation.
     */
    listSkillsets(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-listSkillsets", options);
            try {
                const result = yield this.client.skillsets.list(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return result.skillsets.map(generatedSkillsetToPublicSkillset);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves a list of names of existing Skillsets in the service.
     * @param options Options to the list Skillsets operation.
     */
    listSkillsetsNames(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-listSkillsetsNames", options);
            try {
                const result = yield this.client.skillsets.list(Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { select: "name" }));
                return result.skillsets.map((sks) => sks.name);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves information about an Indexer.
     * @param indexerName The name of the Indexer.
     * @param options Additional optional arguments.
     */
    getIndexer(indexerName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-getIndexer", options);
            try {
                const result = yield this.client.indexers.get(indexerName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves information about a DataSource
     * @param dataSourceName The name of the DataSource
     * @param options Additional optional arguments
     */
    getDataSourceConnection(dataSourceConnectionName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-getDataSourceConnection", options);
            try {
                const result = yield this.client.dataSources.get(dataSourceConnectionName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return generatedDataSourceToPublicDataSource(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Retrieves information about an Skillset.
     * @param indexName The name of the Skillset.
     * @param options Additional optional arguments.
     */
    getSkillset(skillsetName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-getSkillset", options);
            try {
                const result = yield this.client.skillsets.get(skillsetName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return generatedSkillsetToPublicSkillset(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a new indexer in a search service.
     * @param indexer The indexer definition to create in a search service.
     * @param options Additional optional arguments.
     */
    createIndexer(indexer, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-createIndexer", options);
            try {
                const result = yield this.client.indexers.create(indexer, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a new dataSource in a search service.
     * @param dataSourceConnection The dataSource definition to create in a search service.
     * @param options Additional optional arguments.
     */
    createDataSourceConnection(dataSourceConnection, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-createDataSourceConnection", options);
            try {
                const result = yield this.client.dataSources.create(Object.assign(Object.assign({}, dataSourceConnection), { credentials: {
                        connectionString: dataSourceConnection.connectionString
                    } }), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return generatedDataSourceToPublicDataSource(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a new skillset in a search service.
     * @param skillset The skillset containing one or more skills to create in a search service.
     * @param options Additional optional arguments.
     */
    createSkillset(skillset, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-createSkillset", options);
            try {
                const result = yield this.client.skillsets.create(publicSkillsetToGeneratedSkillset(skillset), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return generatedSkillsetToPublicSkillset(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a new indexer or modifies an existing one.
     * @param indexer The information describing the indexer to be created/updated.
     * @param options Additional optional arguments.
     */
    createOrUpdateIndexer(indexer, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-createOrUpdateIndexer", options);
            try {
                const etag = options.onlyIfUnchanged ? indexer.etag : undefined;
                const result = yield this.client.indexers.createOrUpdate(indexer.name, indexer, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a new datasource or modifies an existing one.
     * @param dataSourceConnection The information describing the datasource to be created/updated.
     * @param options Additional optional arguments.
     */
    createOrUpdateDataSourceConnection(dataSourceConnection, options = {}) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-createOrUpdateDataSourceConnection", options);
            try {
                const etag = options.onlyIfUnchanged ? dataSourceConnection.etag : undefined;
                const result = yield this.client.dataSources.createOrUpdate(dataSourceConnection.name, Object.assign(Object.assign({}, dataSourceConnection), { credentials: {
                        connectionString: (_a = dataSourceConnection.connectionString) !== null && _a !== void 0 ? _a : "<unchanged>"
                    } }), Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
                return generatedDataSourceToPublicDataSource(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a new Skillset or modifies an existing one.
     * @param skillset The information describing the index to be created.
     * @param options Additional optional arguments.
     */
    createOrUpdateSkillset(skillset, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-createOrUpdateSkillset", options);
            try {
                const etag = options.onlyIfUnchanged ? skillset.etag : undefined;
                const result = yield this.client.skillsets.createOrUpdate(skillset.name, publicSkillsetToGeneratedSkillset(skillset), Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
                return generatedSkillsetToPublicSkillset(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Deletes an existing indexer.
     * @param indexer Indexer/Name of the indexer to delete.
     * @param options Additional optional arguments.
     */
    deleteIndexer(indexer, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-deleteIndexer", options);
            try {
                const indexerName = typeof indexer === "string" ? indexer : indexer.name;
                const etag = typeof indexer === "string"
                    ? undefined
                    : options.onlyIfUnchanged
                        ? indexer.etag
                        : undefined;
                yield this.client.indexers.deleteMethod(indexerName, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Deletes an existing datasource.
     * @param dataSource Datasource/Name of the datasource to delete.
     * @param options Additional optional arguments.
     */
    deleteDataSourceConnection(dataSourceConnection, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-deleteDataSourceConnection", options);
            try {
                const dataSourceConnectionName = typeof dataSourceConnection === "string" ? dataSourceConnection : dataSourceConnection.name;
                const etag = typeof dataSourceConnection === "string"
                    ? undefined
                    : options.onlyIfUnchanged
                        ? dataSourceConnection.etag
                        : undefined;
                yield this.client.dataSources.deleteMethod(dataSourceConnectionName, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Deletes an existing Skillset.
     * @param skillset Skillset/Name of the Skillset to delete.
     * @param options Additional optional arguments.
     */
    deleteSkillset(skillset, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-deleteSkillset", options);
            try {
                const skillsetName = typeof skillset === "string" ? skillset : skillset.name;
                const etag = typeof skillset === "string"
                    ? undefined
                    : options.onlyIfUnchanged
                        ? skillset.etag
                        : undefined;
                yield this.client.skillsets.deleteMethod(skillsetName, Object.assign(Object.assign({}, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { ifMatch: etag }));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Returns the current status and execution history of an indexer.
     * @param indexerName The name of the indexer.
     * @param options Additional optional arguments.
     */
    getIndexerStatus(indexerName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-getIndexerStatus", options);
            try {
                const result = yield this.client.indexers.getStatus(indexerName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Resets the change tracking state associated with an indexer.
     * @param indexerName The name of the indexer to reset.
     * @param options Additional optional arguments.
     */
    resetIndexer(indexerName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-resetIndexer", options);
            try {
                yield this.client.indexers.reset(indexerName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Runs an indexer on-demand.
     * @param indexerName The name of the indexer to run.
     * @param options Additional optional arguments.
     */
    runIndexer(indexerName, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("SearchIndexerClient-runIndexer", options);
            try {
                yield this.client.indexers.run(indexerName, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function escapeQuotesIfString(input, previous) {
    let result = input;
    if (typeof input === "string") {
        result = input.replace(/'/g, "''");
        // check if we need to escape this literal
        if (!previous.trim().endsWith("'")) {
            result = `'${result}'`;
        }
    }
    return result;
}
/**
 * Escapes an odata filter expression to avoid errors with quoting string literals.
 * Example usage:
 * ```ts
 * const baseRateMax = 200;
 * const ratingMin = 4;
 * const filter = odata`Rooms/any(room: room/BaseRate lt ${baseRateMax}) and Rating ge ${ratingMin}`;
 * ```
 * For more information on supported syntax see: https://docs.microsoft.com/en-us/azure/search/search-query-odata-filter
 * @param strings
 * @param values
 */
function odata(strings, ...values) {
    const results = [];
    for (let i = 0; i < strings.length; i++) {
        results.push(strings[i]);
        if (i < values.length) {
            results.push(escapeQuotesIfString(values[i], strings[i]));
        }
    }
    return results.join("");
}

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () {
        return coreAuth.AzureKeyCredential;
    }
});
exports.GeographyPoint = GeographyPoint;
exports.IndexDocumentsBatch = IndexDocumentsBatch;
exports.SearchClient = SearchClient$1;
exports.SearchIndexClient = SearchIndexClient;
exports.SearchIndexerClient = SearchIndexerClient;
exports.odata = odata;
//# sourceMappingURL=index.js.map
