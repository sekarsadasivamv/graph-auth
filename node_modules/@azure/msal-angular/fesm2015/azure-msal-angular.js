import { __decorate, __param } from 'tslib';
import { Injectable, InjectionToken, Inject, NgModule } from '@angular/core';
import { BehaviorSubject, from } from 'rxjs';
import { filter, map, mergeMap, tap } from 'rxjs/operators';
import { UserAgentApplication } from 'msal';
import { Router, ActivatedRoute } from '@angular/router';
import { UrlUtils } from 'msal/lib-commonjs/utils/UrlUtils';
import { Location, PlatformLocation, CommonModule } from '@angular/common';
import { WindowUtils } from 'msal/lib-commonjs/utils/WindowUtils';
import { HttpErrorResponse } from '@angular/common/http';

let BroadcastService = class BroadcastService {
    constructor() {
        this._msalSubject = new BehaviorSubject(1);
        this.msalItem$ = this._msalSubject.asObservable();
    }
    broadcast(type, payload) {
        this._msalSubject.next({ type, payload });
    }
    getMSALSubject() {
        return this._msalSubject;
    }
    getMSALItem() {
        return this.msalItem$;
    }
    subscribe(type, callback) {
        return this.msalItem$
            .pipe(filter(message => message.type === type), map(message => message.payload))
            .subscribe(callback);
    }
};
BroadcastService = __decorate([
    Injectable()
], BroadcastService);

class MSALError {
    constructor(error, errorDesc, scopes) {
        this._error = "";
        this._errorDesc = "";
        this._scopes = "";
        this._error = error;
        if (errorDesc) {
            this._errorDesc = errorDesc;
        }
        if (scopes) {
            this._scopes = scopes;
        }
    }
    get error() {
        return this._error;
    }
    set error(value) {
        this._error = value;
    }
    get errorDesc() {
        return this._errorDesc;
    }
    set errorDesc(value) {
        this._errorDesc = value;
    }
    get scopes() {
        return this._scopes;
    }
    set scopes(value) {
        this._scopes = value;
    }
}

const MSAL_CONFIG = new InjectionToken("MSAL_CONFIG");
const MSAL_CONFIG_ANGULAR = new InjectionToken("MSAL_CONFIG_ANGULAR");

const buildMsalConfig = (config) => {
    return Object.assign(Object.assign({}, config), { framework: Object.assign(Object.assign({}, config.framework), { isAngular: true }) });
};
const Éµ0 = buildMsalConfig;
let MsalService = class MsalService extends UserAgentApplication {
    constructor(msalConfig, msalAngularConfig, router, broadcastService) {
        super(buildMsalConfig(msalConfig));
        this.msalConfig = msalConfig;
        this.msalAngularConfig = msalAngularConfig;
        this.router = router;
        this.broadcastService = broadcastService;
        window.addEventListener("msal:popUpHashChanged", (e) => {
            this.getLogger().verbose("popUpHashChanged ");
        });
        window.addEventListener('msal:popUpClosed', (e) => {
            var errorParts = e.detail.split('|');
            var msalError = new MSALError(errorParts[0], errorParts[1]);
            if (this.getLoginInProgress()) {
                broadcastService.broadcast('msal:loginFailure', msalError);
                this.setloginInProgress(false);
            }
            else if (this.getAcquireTokenInProgress()) {
                broadcastService.broadcast('msal:acquireTokenFailure', msalError);
                this.setAcquireTokenInProgress(false);
            }
        });
        this.router.events.subscribe(event => {
            for (var i = 0; i < router.config.length; i++) {
                if (!router.config[i].canActivate) {
                    if (this.msalAngularConfig.unprotectedResources) {
                        if (!this.isUnprotectedResource(router.config[i].path) && !this.isEmpty(router.config[i].path)) {
                            this.msalAngularConfig.unprotectedResources.push(router.config[i].path);
                        }
                    }
                }
            }
        });
    }
    isUnprotectedResource(url) {
        const frameworkUnprotectedResources = this.msalConfig.framework && this.msalConfig.framework.unprotectedResources;
        const configUnprotectedResources = this.msalAngularConfig.unprotectedResources || [];
        const unprotectedResources = frameworkUnprotectedResources && frameworkUnprotectedResources.length ? frameworkUnprotectedResources : configUnprotectedResources;
        return unprotectedResources.some(resource => url.indexOf(resource) > -1);
    }
    isEmpty(str) {
        return (typeof str === "undefined" || !str || 0 === str.length);
    }
    getCacheStorage() {
        return this.cacheStorage;
    }
    loginPopup(request) {
        return super.loginPopup(request)
            .then((authResponse) => {
            this.broadcastService.broadcast("msal:loginSuccess", authResponse);
            return authResponse;
        })
            .catch((error) => {
            this.broadcastService.broadcast("msal:loginFailure", error);
            this.getLogger().error("Error during login:\n" + error.errorMessage);
            throw error;
        });
    }
    acquireTokenSilent(request) {
        return super.acquireTokenSilent(request)
            .then((authResponse) => {
            this.broadcastService.broadcast('msal:acquireTokenSuccess', authResponse);
            return authResponse;
        })
            .catch((error) => {
            this.broadcastService.broadcast('msal:acquireTokenFailure', error);
            this.getLogger().error('Error when acquiring token for scopes: ' + request.scopes + " " + error);
            throw error;
        });
    }
    acquireTokenPopup(request) {
        return super.acquireTokenPopup(request)
            .then((authResponse) => {
            this.broadcastService.broadcast('msal:acquireTokenSuccess', authResponse);
            return authResponse;
        })
            .catch((error) => {
            this.broadcastService.broadcast('msal:acquireTokenFailure', error);
            this.getLogger().error('Error when acquiring token for scopes : ' + request.scopes + " " + error);
            throw error;
        });
    }
    handleRedirectCallback(authOrTokenCallback, errorReceivedCallback) {
        super.handleRedirectCallback((authError, authResponse) => {
            if (authResponse) {
                if (authResponse.tokenType === "id_token") {
                    this.broadcastService.broadcast("msal:loginSuccess", authResponse);
                }
                else {
                    this.broadcastService.broadcast("msal:acquireTokenSuccess", authResponse);
                }
                if (errorReceivedCallback) {
                    authOrTokenCallback(authResponse);
                }
                else {
                    authOrTokenCallback(null, authResponse);
                }
            }
            else if (authError) {
                if (authResponse.tokenType === "id_token") {
                    this.broadcastService.broadcast("msal:loginFailure", authError);
                }
                else {
                    this.broadcastService.broadcast("msal:acquireTokenFailure", authError);
                }
                if (errorReceivedCallback) {
                    errorReceivedCallback(authError, authResponse.accountState);
                }
                else {
                    authOrTokenCallback(authError);
                }
            }
        });
    }
    clearCacheForScope(accessToken) {
        return super.clearCacheForScope(accessToken);
    }
    getScopesForEndpoint(endpoint) {
        if (this.msalConfig.framework && this.msalConfig.framework.unprotectedResources) {
            this.getLogger().info("msalConfig.framework.unprotectedResources is deprecated, use msalAngularConfig.unprotectedResources");
        }
        // if user specified list of unprotectedResources, no need to send token to these endpoints, return null.
        const isUnprotected = this.isUnprotectedResource(endpoint);
        if (isUnprotected) {
            return null;
        }
        const frameworkProtectedResourceMap = this.msalConfig.framework && this.msalConfig.framework.protectedResourceMap;
        if (frameworkProtectedResourceMap) {
            this.getLogger().info("msalConfig.framework.protectedResourceMap is deprecated, use msalAngularConfig.protectedResourceMap");
        }
        const protectedResourceMap = frameworkProtectedResourceMap && frameworkProtectedResourceMap.size ? frameworkProtectedResourceMap : new Map(this.msalAngularConfig.protectedResourceMap);
        // process all protected resources and send the matched one
        const keyForEndpoint = Array.from(protectedResourceMap.keys()).find(key => endpoint.indexOf(key) > -1);
        if (keyForEndpoint) {
            return protectedResourceMap.get(keyForEndpoint);
        }
        /*
         * default resource will be clientid if nothing specified
         * App will use idtoken for calls to itself
         * check if it's staring from http or https, needs to match with app host
         */
        if (endpoint.indexOf("http://") > -1 || endpoint.indexOf("https://") > -1) {
            if (UrlUtils.getHostFromUri(endpoint) === UrlUtils.getHostFromUri(super.getRedirectUri())) {
                return new Array(this.msalConfig.auth.clientId);
            }
        }
        else {
            /*
             * in angular level, the url for $http interceptor call could be relative url,
             * if it's relative call, we'll treat it as app backend call.
             */
            return new Array(this.msalConfig.auth.clientId);
        }
        // if not the app's own backend or not a domain listed in the endpoints structure
        return null;
    }
};
MsalService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG_ANGULAR,] }] },
    { type: Router },
    { type: BroadcastService }
];
MsalService = __decorate([
    Injectable(),
    __param(0, Inject(MSAL_CONFIG)),
    __param(1, Inject(MSAL_CONFIG_ANGULAR))
], MsalService);

let MsalGuard = class MsalGuard {
    constructor(msalConfig, msalAngularConfig, authService, router, activatedRoute, location, platformLocation, broadcastService) {
        this.msalConfig = msalConfig;
        this.msalAngularConfig = msalAngularConfig;
        this.authService = authService;
        this.router = router;
        this.activatedRoute = activatedRoute;
        this.location = location;
        this.platformLocation = platformLocation;
        this.broadcastService = broadcastService;
    }
    canActivate(route, state) {
        this.authService.getLogger().verbose("location change event from old url to new url");
        // If a page with MSAL Guard is set as the redirect for acquireTokenSilent,
        // short-circuit to prevent redirecting or popups.
        if (UrlUtils.urlContainsHash(window.location.hash) && WindowUtils.isInIframe()) {
            this.authService.getLogger().warning("redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication.");
            return false;
        }
        if (!this.authService.getAccount()) {
            if (this.msalAngularConfig.popUp) {
                return this.authService.loginPopup({
                    scopes: this.msalAngularConfig.consentScopes,
                    extraQueryParameters: this.msalAngularConfig.extraQueryParameters
                })
                    .then(() => true)
                    .catch(() => false);
            }
            const routePath = `${window.location.origin}${state.url}`;
            this.authService.loginRedirect({
                redirectStartPage: routePath,
                scopes: this.msalAngularConfig.consentScopes,
                extraQueryParameters: this.msalAngularConfig.extraQueryParameters
            });
        }
        else {
            return this.authService.acquireTokenSilent({
                scopes: [this.msalConfig.auth.clientId]
            })
                .then((result) => {
                this.broadcastService.broadcast("msal:loginSuccess", result);
                return true;
            })
                .catch((error) => {
                this.broadcastService.broadcast("msal:loginFailure", error);
                return false;
            });
        }
    }
};
MsalGuard.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_CONFIG_ANGULAR,] }] },
    { type: MsalService },
    { type: Router },
    { type: ActivatedRoute },
    { type: Location },
    { type: PlatformLocation },
    { type: BroadcastService }
];
MsalGuard = __decorate([
    Injectable(),
    __param(0, Inject(MSAL_CONFIG)),
    __param(1, Inject(MSAL_CONFIG_ANGULAR))
], MsalGuard);

let MsalInterceptor = class MsalInterceptor {
    constructor(auth, broadcastService) {
        this.auth = auth;
        this.broadcastService = broadcastService;
    }
    intercept(req, next) {
        const scopes = this.auth.getScopesForEndpoint(req.url);
        this.auth.getLogger().verbose('Url: ' + req.url + ' maps to scopes: ' + scopes);
        // If there are no scopes set for this request, do nothing.
        if (!scopes) {
            return next.handle(req);
        }
        let accessToken;
        // Acquire a token for this request, and attach as proper auth header.
        return from(this.auth.acquireTokenSilent({ scopes })
            .then((response) => {
            accessToken = response.accessToken;
            const authHeader = `Bearer ${response.accessToken}`;
            return req.clone({
                setHeaders: {
                    Authorization: authHeader,
                }
            });
        }))
            .pipe(mergeMap(nextReq => next.handle(nextReq)), tap(event => { }, err => {
            if (err instanceof HttpErrorResponse && err.status === 401) {
                this.auth.clearCacheForScope(accessToken);
                this.broadcastService.broadcast('msal:notAuthorized', err.message);
            }
        }));
    }
};
MsalInterceptor.ctorParameters = () => [
    { type: MsalService },
    { type: BroadcastService }
];
MsalInterceptor = __decorate([
    Injectable()
], MsalInterceptor);

const defaultMsalAngularConfiguration = {
    consentScopes: [],
    popUp: false,
    extraQueryParameters: {},
    unprotectedResources: [],
    protectedResourceMap: []
};

var MsalModule_1;
let MsalModule = MsalModule_1 = class MsalModule {
    static forRoot(config, angularConfig = defaultMsalAngularConfiguration) {
        return {
            ngModule: MsalModule_1,
            providers: [
                {
                    provide: MSAL_CONFIG,
                    useValue: config
                },
                {
                    provide: MSAL_CONFIG_ANGULAR,
                    useValue: angularConfig
                },
                MsalService
            ]
        };
    }
};
MsalModule = MsalModule_1 = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [],
        providers: [MsalGuard, BroadcastService],
    })
], MsalModule);

/**
 * Generated bundle index. Do not edit.
 */

export { BroadcastService, MSAL_CONFIG, MSAL_CONFIG_ANGULAR, MsalGuard, MsalInterceptor, MsalModule, MsalService, defaultMsalAngularConfiguration as Éµa };
//# sourceMappingURL=azure-msal-angular.js.map
